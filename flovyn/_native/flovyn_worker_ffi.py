

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("flovyn_worker_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_flovyn_worker_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_get_workflow_events() != 56284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_query_workflow() != 34193:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_reject_promise() != 16883:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_resolve_promise() != 56407:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_signal_with_start_workflow() != 57504:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_signal_workflow() != 6467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_start_workflow() != 16527:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_complete_task() != 65396:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_complete_workflow_activation() != 19979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_connection_info() != 13771:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_max_concurrent_tasks() != 64320:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_max_concurrent_workflows() != 43894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_metrics() != 43755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_org_id() != 12658:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_pause_reason() != 57959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_queue() != 9508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_registration_info() != 53811:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_server_url() != 61456:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_started_at_ms() != 37224:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_status() != 13286:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_uptime_ms() != 20157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_worker_id() != 3385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_worker_identity() != 11464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_initiate_shutdown() != 32789:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_paused() != 55999:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_running() != 22464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_shutdown_requested() != 53388:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_pause() != 59092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_pending_lifecycle_event_count() != 12728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_lifecycle_events() != 37423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_task_activation() != 13630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_workflow_activation() != 36367:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_register() != 36828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_resume() != 24860:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_attempt() != 55703:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_is_cancelled() != 35105:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream() != 8842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_data() != 61427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_error() != 9512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_progress() != 51678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_token() != 45142:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_task_execution_id() != 6942:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_workflow_execution_id() != 43823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_clear_all() != 4373:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_clear_state() != 41051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_command_count() != 14060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_create_promise() != 49041:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_current_time_millis() != 38125:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_drain_signals() != 26519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_get_state() != 9129:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_has_signal() != 27653:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_is_cancellation_requested() != 18572:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_pending_signal_count() != 13337:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_random() != 22015:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_random_uuid() != 49751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_record_operation_result() != 25439:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_request_cancellation() != 64432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_run_operation() != 56437:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_schedule_child_workflow() != 23503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_schedule_task() != 57245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_set_state() != 16216:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_start_timer() != 38573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_state_keys() != 6962:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_take_commands() != 63915:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_wait_for_signal() != 4847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_workflow_execution_id() != 54462:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_constructor_coreclient_new() != 52450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_flovyn_worker_ffi_checksum_constructor_coreworker_new() != 17947:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_coreclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_coreclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_coreclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_coreclient.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_constructor_coreclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_constructor_coreclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_get_workflow_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_get_workflow_events.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_query_workflow.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_query_workflow.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_reject_promise.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_reject_promise.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_resolve_promise.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_resolve_promise.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_signal_with_start_workflow.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_signal_with_start_workflow.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_signal_workflow.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_signal_workflow.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_start_workflow.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_start_workflow.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_coreworker.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_coreworker.restype = ctypes.c_void_p
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_coreworker.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_coreworker.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_constructor_coreworker_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_constructor_coreworker_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_complete_task.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_complete_task.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_complete_workflow_activation.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_complete_workflow_activation.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_connection_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_connection_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_max_concurrent_tasks.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_max_concurrent_tasks.restype = ctypes.c_uint32
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_max_concurrent_workflows.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_max_concurrent_workflows.restype = ctypes.c_uint32
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_metrics.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_metrics.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_org_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_org_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_pause_reason.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_pause_reason.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_queue.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_queue.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_registration_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_registration_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_server_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_server_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_started_at_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_started_at_ms.restype = ctypes.c_int64
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_uptime_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_uptime_ms.restype = ctypes.c_int64
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_worker_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_worker_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_worker_identity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_worker_identity.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_initiate_shutdown.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_initiate_shutdown.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_paused.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_paused.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_running.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_running.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_shutdown_requested.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_shutdown_requested.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_pause.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_pause.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_pending_lifecycle_event_count.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_pending_lifecycle_event_count.restype = ctypes.c_uint32
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_lifecycle_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_lifecycle_events.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_task_activation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_task_activation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_workflow_activation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_workflow_activation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_register.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_register.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_resume.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_resume.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_ffitaskcontext.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_ffitaskcontext.restype = ctypes.c_void_p
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_ffitaskcontext.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_ffitaskcontext.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_attempt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_attempt.restype = ctypes.c_uint32
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_is_cancelled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_is_cancelled.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_data.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_data.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_error.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_error.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.c_double,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_progress.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_token.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_token.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_task_execution_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_task_execution_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_workflow_execution_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_workflow_execution_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_ffiworkflowcontext.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_ffiworkflowcontext.restype = ctypes.c_void_p
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_ffiworkflowcontext.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_ffiworkflowcontext.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_clear_all.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_clear_all.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_clear_state.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_clear_state.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_command_count.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_command_count.restype = ctypes.c_uint32
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_create_promise.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_create_promise.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_current_time_millis.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_current_time_millis.restype = ctypes.c_int64
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_drain_signals.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_drain_signals.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_get_state.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_get_state.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_has_signal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_has_signal.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_is_cancellation_requested.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_is_cancellation_requested.restype = ctypes.c_int8
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_pending_signal_count.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_pending_signal_count.restype = ctypes.c_uint32
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_random.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_random.restype = ctypes.c_double
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_random_uuid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_random_uuid.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_record_operation_result.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_record_operation_result.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_request_cancellation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_request_cancellation.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_run_operation.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_run_operation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_schedule_child_workflow.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_schedule_child_workflow.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_schedule_task.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_schedule_task.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_set_state.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_set_state.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_start_timer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_start_timer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_state_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_state_keys.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_take_commands.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_take_commands.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_wait_for_signal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_wait_for_signal.restype = _UniffiRustBuffer
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_workflow_execution_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_workflow_execution_id.restype = _UniffiRustBuffer
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_flovyn_worker_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_get_workflow_events.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_get_workflow_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_query_workflow.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_query_workflow.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_reject_promise.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_reject_promise.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_resolve_promise.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_resolve_promise.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_signal_with_start_workflow.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_signal_with_start_workflow.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_signal_workflow.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_signal_workflow.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_start_workflow.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreclient_start_workflow.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_complete_task.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_complete_task.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_complete_workflow_activation.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_complete_workflow_activation.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_connection_info.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_connection_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_max_concurrent_tasks.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_max_concurrent_tasks.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_max_concurrent_workflows.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_max_concurrent_workflows.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_metrics.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_metrics.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_org_id.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_org_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_pause_reason.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_pause_reason.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_queue.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_queue.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_registration_info.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_registration_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_server_url.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_server_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_started_at_ms.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_started_at_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_status.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_uptime_ms.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_uptime_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_worker_id.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_worker_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_worker_identity.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_get_worker_identity.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_initiate_shutdown.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_initiate_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_paused.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_paused.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_running.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_running.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_shutdown_requested.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_is_shutdown_requested.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_pause.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_pause.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_pending_lifecycle_event_count.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_pending_lifecycle_event_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_lifecycle_events.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_lifecycle_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_task_activation.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_task_activation.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_workflow_activation.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_poll_workflow_activation.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_register.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_register.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_resume.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_coreworker_resume.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_attempt.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_attempt.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_is_cancelled.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_is_cancelled.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_data.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_error.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_progress.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_token.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_stream_token.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_task_execution_id.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_task_execution_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_workflow_execution_id.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffitaskcontext_workflow_execution_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_clear_all.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_clear_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_clear_state.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_clear_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_command_count.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_command_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_create_promise.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_create_promise.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_current_time_millis.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_current_time_millis.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_drain_signals.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_drain_signals.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_get_state.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_get_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_has_signal.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_has_signal.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_is_cancellation_requested.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_is_cancellation_requested.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_pending_signal_count.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_pending_signal_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_random.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_random.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_random_uuid.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_random_uuid.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_record_operation_result.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_record_operation_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_request_cancellation.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_request_cancellation.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_run_operation.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_run_operation.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_schedule_child_workflow.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_schedule_child_workflow.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_schedule_task.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_schedule_task.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_set_state.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_set_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_start_timer.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_start_timer.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_state_keys.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_state_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_take_commands.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_take_commands.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_wait_for_signal.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_wait_for_signal.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_workflow_execution_id.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_method_ffiworkflowcontext_workflow_execution_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_constructor_coreclient_new.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_constructor_coreclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_constructor_coreworker_new.argtypes = (
)
_UniffiLib.uniffi_flovyn_worker_ffi_checksum_constructor_coreworker_new.restype = ctypes.c_uint16
_UniffiLib.ffi_flovyn_worker_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_flovyn_worker_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class CoreClientProtocol(typing.Protocol):
    """
    The client object for FFI, used for workflow operations.

    CoreClient provides:
    - Starting workflows
    - Querying workflow state
    - Sending signals to workflows
    - Cancelling workflows
    """

    def get_workflow_events(self, workflow_execution_id: "str"):
        """
        Get the events for a workflow execution.

        # Arguments
        * `workflow_execution_id` - The workflow execution ID

        # Returns
        A list of workflow events as JSON bytes.
        """

        raise NotImplementedError
    def query_workflow(self, workflow_execution_id: "str",query_name: "str",params: "bytes"):
        """
        Query workflow state.

        # Arguments
        * `workflow_execution_id` - The workflow execution ID
        * `query_name` - The name of the query to execute
        * `params` - Query parameters as JSON bytes

        # Returns
        The query result as JSON bytes.
        """

        raise NotImplementedError
    def reject_promise(self, promise_id: "str",error: "str"):
        """
        Reject a durable promise with an error.

        This allows external systems to reject promises that were created
        by workflows using `ctx.promise()`.

        # Arguments
        * `promise_id` - The promise ID (format: workflow_execution_id/promise-name)
        * `error` - The error message
        """

        raise NotImplementedError
    def resolve_promise(self, promise_id: "str",value: "bytes"):
        """
        Resolve a durable promise with a value.

        This allows external systems to resolve promises that were created
        by workflows using `ctx.promise()`.

        # Arguments
        * `promise_id` - The promise ID (format: workflow_execution_id/promise-name)
        * `value` - The value to resolve the promise with (JSON bytes)
        """

        raise NotImplementedError
    def signal_with_start_workflow(self, workflow_id: "str",workflow_kind: "str",workflow_input: "bytes",queue: "typing.Optional[str]",signal_name: "str",signal_value: "bytes"):
        """
        Send a signal to an existing workflow, or create a new workflow and send the signal.

        This is an atomic operation - either the workflow exists and receives the signal,
        or a new workflow is created with the signal. This prevents race conditions
        where a workflow might be created between checking for existence and signaling.

        # Arguments
        * `workflow_id` - The workflow ID (used as idempotency key)
        * `workflow_kind` - The type/kind of workflow to create if it doesn't exist
        * `workflow_input` - Serialized input for the workflow (JSON bytes)
        * `queue` - The task queue
        * `signal_name` - The name of the signal
        * `signal_value` - Serialized signal value (JSON bytes)

        # Returns
        Information about whether the workflow was created and the signal event sequence.
        """

        raise NotImplementedError
    def signal_workflow(self, workflow_execution_id: "str",signal_name: "str",signal_value: "bytes"):
        """
        Send a signal to an existing workflow.

        # Arguments
        * `workflow_execution_id` - The workflow execution ID
        * `signal_name` - The name of the signal
        * `signal_value` - Serialized signal value (JSON bytes)

        # Returns
        The sequence number of the signal event.
        """

        raise NotImplementedError
    def start_workflow(self, workflow_kind: "str",input: "bytes",queue: "typing.Optional[str]",workflow_version: "typing.Optional[str]",idempotency_key: "typing.Optional[str]"):
        """
        Start a new workflow execution.

        # Arguments
        * `workflow_kind` - The type/kind of workflow to start
        * `input` - Serialized input as JSON bytes
        * `queue` - Optional task queue (defaults to "default")
        * `workflow_version` - Optional workflow version
        * `idempotency_key` - Optional idempotency key for deduplication

        # Returns
        The workflow execution ID and idempotency information.
        """

        raise NotImplementedError


class CoreClient:
    """
    The client object for FFI, used for workflow operations.

    CoreClient provides:
    - Starting workflows
    - Querying workflow state
    - Sending signals to workflows
    - Cancelling workflows
    """

    _pointer: ctypes.c_void_p
    def __init__(self, config: "ClientConfig"):
        """
        Create a new CoreClient with the given configuration.
        """

        _UniffiConverterTypeClientConfig.check_lower(config)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_constructor_coreclient_new,
        _UniffiConverterTypeClientConfig.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_coreclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_coreclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_workflow_events(self, workflow_execution_id: "str") -> "typing.List[WorkflowEventRecord]":
        """
        Get the events for a workflow execution.

        # Arguments
        * `workflow_execution_id` - The workflow execution ID

        # Returns
        A list of workflow events as JSON bytes.
        """

        _UniffiConverterString.check_lower(workflow_execution_id)
        
        return _UniffiConverterSequenceTypeWorkflowEventRecord.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_get_workflow_events,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(workflow_execution_id))
        )





    def query_workflow(self, workflow_execution_id: "str",query_name: "str",params: "bytes") -> "bytes":
        """
        Query workflow state.

        # Arguments
        * `workflow_execution_id` - The workflow execution ID
        * `query_name` - The name of the query to execute
        * `params` - Query parameters as JSON bytes

        # Returns
        The query result as JSON bytes.
        """

        _UniffiConverterString.check_lower(workflow_execution_id)
        
        _UniffiConverterString.check_lower(query_name)
        
        _UniffiConverterBytes.check_lower(params)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_query_workflow,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(workflow_execution_id),
        _UniffiConverterString.lower(query_name),
        _UniffiConverterBytes.lower(params))
        )





    def reject_promise(self, promise_id: "str",error: "str") -> None:
        """
        Reject a durable promise with an error.

        This allows external systems to reject promises that were created
        by workflows using `ctx.promise()`.

        # Arguments
        * `promise_id` - The promise ID (format: workflow_execution_id/promise-name)
        * `error` - The error message
        """

        _UniffiConverterString.check_lower(promise_id)
        
        _UniffiConverterString.check_lower(error)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_reject_promise,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(promise_id),
        _UniffiConverterString.lower(error))






    def resolve_promise(self, promise_id: "str",value: "bytes") -> None:
        """
        Resolve a durable promise with a value.

        This allows external systems to resolve promises that were created
        by workflows using `ctx.promise()`.

        # Arguments
        * `promise_id` - The promise ID (format: workflow_execution_id/promise-name)
        * `value` - The value to resolve the promise with (JSON bytes)
        """

        _UniffiConverterString.check_lower(promise_id)
        
        _UniffiConverterBytes.check_lower(value)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_resolve_promise,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(promise_id),
        _UniffiConverterBytes.lower(value))






    def signal_with_start_workflow(self, workflow_id: "str",workflow_kind: "str",workflow_input: "bytes",queue: "typing.Optional[str]",signal_name: "str",signal_value: "bytes") -> "SignalWithStartResponse":
        """
        Send a signal to an existing workflow, or create a new workflow and send the signal.

        This is an atomic operation - either the workflow exists and receives the signal,
        or a new workflow is created with the signal. This prevents race conditions
        where a workflow might be created between checking for existence and signaling.

        # Arguments
        * `workflow_id` - The workflow ID (used as idempotency key)
        * `workflow_kind` - The type/kind of workflow to create if it doesn't exist
        * `workflow_input` - Serialized input for the workflow (JSON bytes)
        * `queue` - The task queue
        * `signal_name` - The name of the signal
        * `signal_value` - Serialized signal value (JSON bytes)

        # Returns
        Information about whether the workflow was created and the signal event sequence.
        """

        _UniffiConverterString.check_lower(workflow_id)
        
        _UniffiConverterString.check_lower(workflow_kind)
        
        _UniffiConverterBytes.check_lower(workflow_input)
        
        _UniffiConverterOptionalString.check_lower(queue)
        
        _UniffiConverterString.check_lower(signal_name)
        
        _UniffiConverterBytes.check_lower(signal_value)
        
        return _UniffiConverterTypeSignalWithStartResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_signal_with_start_workflow,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(workflow_id),
        _UniffiConverterString.lower(workflow_kind),
        _UniffiConverterBytes.lower(workflow_input),
        _UniffiConverterOptionalString.lower(queue),
        _UniffiConverterString.lower(signal_name),
        _UniffiConverterBytes.lower(signal_value))
        )





    def signal_workflow(self, workflow_execution_id: "str",signal_name: "str",signal_value: "bytes") -> "SignalWorkflowResponse":
        """
        Send a signal to an existing workflow.

        # Arguments
        * `workflow_execution_id` - The workflow execution ID
        * `signal_name` - The name of the signal
        * `signal_value` - Serialized signal value (JSON bytes)

        # Returns
        The sequence number of the signal event.
        """

        _UniffiConverterString.check_lower(workflow_execution_id)
        
        _UniffiConverterString.check_lower(signal_name)
        
        _UniffiConverterBytes.check_lower(signal_value)
        
        return _UniffiConverterTypeSignalWorkflowResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_signal_workflow,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(workflow_execution_id),
        _UniffiConverterString.lower(signal_name),
        _UniffiConverterBytes.lower(signal_value))
        )





    def start_workflow(self, workflow_kind: "str",input: "bytes",queue: "typing.Optional[str]",workflow_version: "typing.Optional[str]",idempotency_key: "typing.Optional[str]") -> "StartWorkflowResponse":
        """
        Start a new workflow execution.

        # Arguments
        * `workflow_kind` - The type/kind of workflow to start
        * `input` - Serialized input as JSON bytes
        * `queue` - Optional task queue (defaults to "default")
        * `workflow_version` - Optional workflow version
        * `idempotency_key` - Optional idempotency key for deduplication

        # Returns
        The workflow execution ID and idempotency information.
        """

        _UniffiConverterString.check_lower(workflow_kind)
        
        _UniffiConverterBytes.check_lower(input)
        
        _UniffiConverterOptionalString.check_lower(queue)
        
        _UniffiConverterOptionalString.check_lower(workflow_version)
        
        _UniffiConverterOptionalString.check_lower(idempotency_key)
        
        return _UniffiConverterTypeStartWorkflowResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreclient_start_workflow,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(workflow_kind),
        _UniffiConverterBytes.lower(input),
        _UniffiConverterOptionalString.lower(queue),
        _UniffiConverterOptionalString.lower(workflow_version),
        _UniffiConverterOptionalString.lower(idempotency_key))
        )






class _UniffiConverterTypeCoreClient:

    @staticmethod
    def lift(value: int):
        return CoreClient._make_instance_(value)

    @staticmethod
    def check_lower(value: CoreClient):
        if not isinstance(value, CoreClient):
            raise TypeError("Expected CoreClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CoreClientProtocol):
        if not isinstance(value, CoreClient):
            raise TypeError("Expected CoreClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CoreClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class CoreWorkerProtocol(typing.Protocol):
    """
    The main worker object exposed to foreign languages via FFI.

    CoreWorker manages:
    - Connection to the Flovyn server
    - Worker registration
    - Polling for workflow and task activations
    - Processing completions
    """

    def complete_task(self, completion: "TaskCompletion"):
        """
        Complete a task activation.

        This sends the task result back to the server.
        """

        raise NotImplementedError
    def complete_workflow_activation(self, context: "FfiWorkflowContext",status: "WorkflowCompletionStatus"):
        """
        Complete a workflow activation.

        This extracts commands from the context and sends them along with
        the completion status to the server.

        # Arguments

        * `context` - The workflow context (commands are extracted from this)
        * `status` - The completion status (Completed, Suspended, Cancelled, or Failed)
        """

        raise NotImplementedError
    def get_connection_info(self, ):
        """
        Get connection information.

        Returns information about the worker's connection to the server.
        """

        raise NotImplementedError
    def get_max_concurrent_tasks(self, ):
        """
        Get the maximum concurrent tasks setting.
        """

        raise NotImplementedError
    def get_max_concurrent_workflows(self, ):
        """
        Get the maximum concurrent workflows setting.
        """

        raise NotImplementedError
    def get_metrics(self, ):
        """
        Get worker metrics.

        Returns a record containing various worker metrics.
        """

        raise NotImplementedError
    def get_org_id(self, ):
        """
        Get the org ID.
        """

        raise NotImplementedError
    def get_pause_reason(self, ):
        """
        Get the pause reason (if paused).
        """

        raise NotImplementedError
    def get_queue(self, ):
        """
        Get the queue name.
        """

        raise NotImplementedError
    def get_registration_info(self, ):
        """
        Get registration information.

        Returns information about the worker's registration with the server.
        """

        raise NotImplementedError
    def get_server_url(self, ):
        """
        Get the server URL.
        """

        raise NotImplementedError
    def get_started_at_ms(self, ):
        """
        Get the worker start time in milliseconds since Unix epoch.
        """

        raise NotImplementedError
    def get_status(self, ):
        """
        Get the current worker status as a string.
        """

        raise NotImplementedError
    def get_uptime_ms(self, ):
        """
        Get the worker uptime in milliseconds.

        Returns the number of milliseconds since the worker was created.
        """

        raise NotImplementedError
    def get_worker_id(self, ):
        """
        Get the server-assigned worker ID (if registered).
        """

        raise NotImplementedError
    def get_worker_identity(self, ):
        """
        Get the worker identity.
        """

        raise NotImplementedError
    def initiate_shutdown(self, ):
        """
        Initiate graceful shutdown of the worker.

        This signals that the worker should stop polling for new work
        and finish any in-flight tasks.
        """

        raise NotImplementedError
    def is_paused(self, ):
        """
        Check if the worker is paused.
        """

        raise NotImplementedError
    def is_running(self, ):
        """
        Check if the worker is running (not paused and not shutting down).
        """

        raise NotImplementedError
    def is_shutdown_requested(self, ):
        """
        Check if shutdown has been requested.
        """

        raise NotImplementedError
    def pause(self, reason: "str"):
        """
        Pause the worker.

        When paused, the worker will not poll for new work but will continue
        processing any in-flight work.

        Returns an error if the worker is not in Running state.
        """

        raise NotImplementedError
    def pending_lifecycle_event_count(self, ):
        """
        Get the count of pending lifecycle events.
        """

        raise NotImplementedError
    def poll_lifecycle_events(self, ):
        """
        Poll for lifecycle events.

        Returns all events that have occurred since the last poll.
        Events are cleared after being returned.
        """

        raise NotImplementedError
    def poll_task_activation(self, ):
        """
        Poll for the next task activation.

        This blocks until work is available or the worker is shut down.
        """

        raise NotImplementedError
    def poll_workflow_activation(self, ):
        """
        Poll for the next workflow activation.

        This blocks until work is available or the worker is shut down.
        Returns `None` if no work is available within the timeout.

        The returned activation includes a replay-aware context that handles:
        - Determinism validation during replay
        - Cached result return for replayed operations
        - Command generation for new operations
        """

        raise NotImplementedError
    def register(self, ):
        """
        Register the worker with the Flovyn server.

        This registers all workflow and task kinds specified in the configuration.
        Returns the server-assigned worker ID.
        """

        raise NotImplementedError
    def resume(self, ):
        """
        Resume the worker.

        Returns an error if the worker is not in Paused state.
        """

        raise NotImplementedError


class CoreWorker:
    """
    The main worker object exposed to foreign languages via FFI.

    CoreWorker manages:
    - Connection to the Flovyn server
    - Worker registration
    - Polling for workflow and task activations
    - Processing completions
    """

    _pointer: ctypes.c_void_p
    def __init__(self, config: "WorkerConfig"):
        """
        Create a new CoreWorker with the given configuration.

        This establishes a connection to the Flovyn server but does not
        register the worker yet. Call `register()` to register.

        Authentication priority:
        1. OAuth2 credentials (if provided, fetches JWT token)
        2. Worker token (if provided)
        3. Placeholder token (for testing)
        """

        _UniffiConverterTypeWorkerConfig.check_lower(config)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_constructor_coreworker_new,
        _UniffiConverterTypeWorkerConfig.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_coreworker, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_coreworker, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def complete_task(self, completion: "TaskCompletion") -> None:
        """
        Complete a task activation.

        This sends the task result back to the server.
        """

        _UniffiConverterTypeTaskCompletion.check_lower(completion)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_complete_task,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTaskCompletion.lower(completion))






    def complete_workflow_activation(self, context: "FfiWorkflowContext",status: "WorkflowCompletionStatus") -> None:
        """
        Complete a workflow activation.

        This extracts commands from the context and sends them along with
        the completion status to the server.

        # Arguments

        * `context` - The workflow context (commands are extracted from this)
        * `status` - The completion status (Completed, Suspended, Cancelled, or Failed)
        """

        _UniffiConverterTypeFfiWorkflowContext.check_lower(context)
        
        _UniffiConverterTypeWorkflowCompletionStatus.check_lower(status)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_complete_workflow_activation,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiWorkflowContext.lower(context),
        _UniffiConverterTypeWorkflowCompletionStatus.lower(status))






    def get_connection_info(self, ) -> "FfiConnectionInfo":
        """
        Get connection information.

        Returns information about the worker's connection to the server.
        """

        return _UniffiConverterTypeFfiConnectionInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_connection_info,self._uniffi_clone_pointer(),)
        )





    def get_max_concurrent_tasks(self, ) -> "int":
        """
        Get the maximum concurrent tasks setting.
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_max_concurrent_tasks,self._uniffi_clone_pointer(),)
        )





    def get_max_concurrent_workflows(self, ) -> "int":
        """
        Get the maximum concurrent workflows setting.
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_max_concurrent_workflows,self._uniffi_clone_pointer(),)
        )





    def get_metrics(self, ) -> "WorkerMetrics":
        """
        Get worker metrics.

        Returns a record containing various worker metrics.
        """

        return _UniffiConverterTypeWorkerMetrics.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_metrics,self._uniffi_clone_pointer(),)
        )





    def get_org_id(self, ) -> "str":
        """
        Get the org ID.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_org_id,self._uniffi_clone_pointer(),)
        )





    def get_pause_reason(self, ) -> "typing.Optional[str]":
        """
        Get the pause reason (if paused).
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_pause_reason,self._uniffi_clone_pointer(),)
        )





    def get_queue(self, ) -> "str":
        """
        Get the queue name.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_queue,self._uniffi_clone_pointer(),)
        )





    def get_registration_info(self, ) -> "typing.Optional[FfiRegistrationInfo]":
        """
        Get registration information.

        Returns information about the worker's registration with the server.
        """

        return _UniffiConverterOptionalTypeFfiRegistrationInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_registration_info,self._uniffi_clone_pointer(),)
        )





    def get_server_url(self, ) -> "str":
        """
        Get the server URL.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_server_url,self._uniffi_clone_pointer(),)
        )





    def get_started_at_ms(self, ) -> "int":
        """
        Get the worker start time in milliseconds since Unix epoch.
        """

        return _UniffiConverterInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_started_at_ms,self._uniffi_clone_pointer(),)
        )





    def get_status(self, ) -> "str":
        """
        Get the current worker status as a string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_status,self._uniffi_clone_pointer(),)
        )





    def get_uptime_ms(self, ) -> "int":
        """
        Get the worker uptime in milliseconds.

        Returns the number of milliseconds since the worker was created.
        """

        return _UniffiConverterInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_uptime_ms,self._uniffi_clone_pointer(),)
        )





    def get_worker_id(self, ) -> "typing.Optional[str]":
        """
        Get the server-assigned worker ID (if registered).
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_worker_id,self._uniffi_clone_pointer(),)
        )





    def get_worker_identity(self, ) -> "typing.Optional[str]":
        """
        Get the worker identity.
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_get_worker_identity,self._uniffi_clone_pointer(),)
        )





    def initiate_shutdown(self, ) -> None:
        """
        Initiate graceful shutdown of the worker.

        This signals that the worker should stop polling for new work
        and finish any in-flight tasks.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_initiate_shutdown,self._uniffi_clone_pointer(),)






    def is_paused(self, ) -> "bool":
        """
        Check if the worker is paused.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_paused,self._uniffi_clone_pointer(),)
        )





    def is_running(self, ) -> "bool":
        """
        Check if the worker is running (not paused and not shutting down).
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_running,self._uniffi_clone_pointer(),)
        )





    def is_shutdown_requested(self, ) -> "bool":
        """
        Check if shutdown has been requested.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_is_shutdown_requested,self._uniffi_clone_pointer(),)
        )





    def pause(self, reason: "str") -> None:
        """
        Pause the worker.

        When paused, the worker will not poll for new work but will continue
        processing any in-flight work.

        Returns an error if the worker is not in Running state.
        """

        _UniffiConverterString.check_lower(reason)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_pause,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(reason))






    def pending_lifecycle_event_count(self, ) -> "int":
        """
        Get the count of pending lifecycle events.
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_pending_lifecycle_event_count,self._uniffi_clone_pointer(),)
        )





    def poll_lifecycle_events(self, ) -> "typing.List[LifecycleEvent]":
        """
        Poll for lifecycle events.

        Returns all events that have occurred since the last poll.
        Events are cleared after being returned.
        """

        return _UniffiConverterSequenceTypeLifecycleEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_lifecycle_events,self._uniffi_clone_pointer(),)
        )





    def poll_task_activation(self, ) -> "typing.Optional[TaskActivation]":
        """
        Poll for the next task activation.

        This blocks until work is available or the worker is shut down.
        """

        return _UniffiConverterOptionalTypeTaskActivation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_task_activation,self._uniffi_clone_pointer(),)
        )





    def poll_workflow_activation(self, ) -> "typing.Optional[WorkflowActivation]":
        """
        Poll for the next workflow activation.

        This blocks until work is available or the worker is shut down.
        Returns `None` if no work is available within the timeout.

        The returned activation includes a replay-aware context that handles:
        - Determinism validation during replay
        - Cached result return for replayed operations
        - Command generation for new operations
        """

        return _UniffiConverterOptionalTypeWorkflowActivation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_poll_workflow_activation,self._uniffi_clone_pointer(),)
        )





    def register(self, ) -> "str":
        """
        Register the worker with the Flovyn server.

        This registers all workflow and task kinds specified in the configuration.
        Returns the server-assigned worker ID.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_register,self._uniffi_clone_pointer(),)
        )





    def resume(self, ) -> None:
        """
        Resume the worker.

        Returns an error if the worker is not in Paused state.
        """

        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_coreworker_resume,self._uniffi_clone_pointer(),)







class _UniffiConverterTypeCoreWorker:

    @staticmethod
    def lift(value: int):
        return CoreWorker._make_instance_(value)

    @staticmethod
    def check_lower(value: CoreWorker):
        if not isinstance(value, CoreWorker):
            raise TypeError("Expected CoreWorker instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CoreWorkerProtocol):
        if not isinstance(value, CoreWorker):
            raise TypeError("Expected CoreWorker instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CoreWorkerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FfiTaskContextProtocol(typing.Protocol):
    """
    Task context for FFI, providing streaming and lifecycle APIs.

    This context is created for each task activation and allows:
    - Streaming tokens, progress, data, and errors to connected clients
    - Checking cancellation status
    - Reporting persisted progress
    """

    def attempt(self, ):
        """
        Get the current attempt number (1-indexed).
        """

        raise NotImplementedError
    def is_cancelled(self, ):
        """
        Check if the task has been cancelled.
        """

        raise NotImplementedError
    def stream(self, event: "FfiStreamEvent"):
        """
        Stream a generic event to connected clients.

        Events are ephemeral (not persisted) and delivered via SSE.
        This method is fire-and-forget; delivery failures are logged but not returned.
        """

        raise NotImplementedError
    def stream_data(self, data: "bytes"):
        """
        Stream data (convenience method).

        Data is provided as JSON bytes.
        """

        raise NotImplementedError
    def stream_error(self, message: "str",code: "typing.Optional[str]"):
        """
        Stream an error notification (convenience method).

        Use to notify clients of recoverable errors during execution.
        For fatal errors, let the task fail normally.
        """

        raise NotImplementedError
    def stream_progress(self, progress: "float",details: "typing.Optional[str]"):
        """
        Stream progress (convenience method).

        Progress values are clamped to 0.0-1.0 during serialization.
        """

        raise NotImplementedError
    def stream_token(self, text: "str"):
        """
        Stream a token (convenience method).

        Use for streaming text generation from language models.
        """

        raise NotImplementedError
    def task_execution_id(self, ):
        """
        Get the task execution ID.
        """

        raise NotImplementedError
    def workflow_execution_id(self, ):
        """
        Get the workflow execution ID (if any).
        """

        raise NotImplementedError


class FfiTaskContext:
    """
    Task context for FFI, providing streaming and lifecycle APIs.

    This context is created for each task activation and allows:
    - Streaming tokens, progress, data, and errors to connected clients
    - Checking cancellation status
    - Reporting persisted progress
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_ffitaskcontext, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_ffitaskcontext, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def attempt(self, ) -> "int":
        """
        Get the current attempt number (1-indexed).
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_attempt,self._uniffi_clone_pointer(),)
        )





    def is_cancelled(self, ) -> "bool":
        """
        Check if the task has been cancelled.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_is_cancelled,self._uniffi_clone_pointer(),)
        )





    def stream(self, event: "FfiStreamEvent") -> "bool":
        """
        Stream a generic event to connected clients.

        Events are ephemeral (not persisted) and delivered via SSE.
        This method is fire-and-forget; delivery failures are logged but not returned.
        """

        _UniffiConverterTypeFfiStreamEvent.check_lower(event)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiStreamEvent.lower(event))
        )





    def stream_data(self, data: "bytes") -> "bool":
        """
        Stream data (convenience method).

        Data is provided as JSON bytes.
        """

        _UniffiConverterBytes.check_lower(data)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_data,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(data))
        )





    def stream_error(self, message: "str",code: "typing.Optional[str]") -> "bool":
        """
        Stream an error notification (convenience method).

        Use to notify clients of recoverable errors during execution.
        For fatal errors, let the task fail normally.
        """

        _UniffiConverterString.check_lower(message)
        
        _UniffiConverterOptionalString.check_lower(code)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_error,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(message),
        _UniffiConverterOptionalString.lower(code))
        )





    def stream_progress(self, progress: "float",details: "typing.Optional[str]") -> "bool":
        """
        Stream progress (convenience method).

        Progress values are clamped to 0.0-1.0 during serialization.
        """

        _UniffiConverterDouble.check_lower(progress)
        
        _UniffiConverterOptionalString.check_lower(details)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_progress,self._uniffi_clone_pointer(),
        _UniffiConverterDouble.lower(progress),
        _UniffiConverterOptionalString.lower(details))
        )





    def stream_token(self, text: "str") -> "bool":
        """
        Stream a token (convenience method).

        Use for streaming text generation from language models.
        """

        _UniffiConverterString.check_lower(text)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_stream_token,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text))
        )





    def task_execution_id(self, ) -> "str":
        """
        Get the task execution ID.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_task_execution_id,self._uniffi_clone_pointer(),)
        )





    def workflow_execution_id(self, ) -> "typing.Optional[str]":
        """
        Get the workflow execution ID (if any).
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffitaskcontext_workflow_execution_id,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFfiTaskContext:

    @staticmethod
    def lift(value: int):
        return FfiTaskContext._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiTaskContext):
        if not isinstance(value, FfiTaskContext):
            raise TypeError("Expected FfiTaskContext instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiTaskContextProtocol):
        if not isinstance(value, FfiTaskContext):
            raise TypeError("Expected FfiTaskContext instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiTaskContextProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FfiWorkflowContextProtocol(typing.Protocol):
    """
    Replay-aware workflow context for FFI.

    This context handles all replay logic internally:
    - Pre-filters events by type for O(1) lookup
    - Validates determinism during replay
    - Returns cached results for replayed operations
    - Only generates commands for NEW operations
    """

    def clear_all(self, ):
        """
        Clear all workflow state.

        Generates ClearState commands for all keys and clears local state.
        """

        raise NotImplementedError
    def clear_state(self, key: "str"):
        """
        Clear workflow state.
        """

        raise NotImplementedError
    def command_count(self, ):
        """
        Get the number of pending commands.
        """

        raise NotImplementedError
    def create_promise(self, name: "str",timeout_ms: "typing.Optional[int]"):
        """
        Create a durable promise.

        Returns:
        - `Resolved` if promise already resolved during replay
        - `Rejected` if promise already rejected during replay
        - `TimedOut` if promise already timed out during replay
        - `Pending` if promise is new or not yet resolved
        """

        raise NotImplementedError
    def current_time_millis(self, ):
        """
        Get the current time in milliseconds since Unix epoch.

        This returns a deterministic value that is the same across replays.
        """

        raise NotImplementedError
    def drain_signals(self, ):
        """
        Drain all pending signals from the queue.
        """

        raise NotImplementedError
    def get_state(self, key: "str"):
        """
        Get workflow state.
        """

        raise NotImplementedError
    def has_signal(self, ):
        """
        Check if any signals are pending in the queue.
        """

        raise NotImplementedError
    def is_cancellation_requested(self, ):
        """
        Check if cancellation has been requested.
        """

        raise NotImplementedError
    def pending_signal_count(self, ):
        """
        Get the number of pending signals.
        """

        raise NotImplementedError
    def random(self, ):
        """
        Generate a deterministic random number in [0, 1).
        """

        raise NotImplementedError
    def random_uuid(self, ):
        """
        Generate a deterministic UUID.

        Each call returns a new UUID that is the same across replays.
        """

        raise NotImplementedError
    def record_operation_result(self, name: "str",result: "bytes"):
        """
        Record the result of an operation that was executed.
        """

        raise NotImplementedError
    def request_cancellation(self, ):
        """
        Request cancellation (called when CancelWorkflow job is received).
        """

        raise NotImplementedError
    def run_operation(self, name: "str"):
        """
        Run a side effect operation.

        Returns:
        - `Cached` if operation already executed during replay
        - `Execute` if operation is new and should be executed
        """

        raise NotImplementedError
    def schedule_child_workflow(self, name: "str",kind: "typing.Optional[str]",input: "bytes",queue: "typing.Optional[str]",priority_seconds: "typing.Optional[int]"):
        """
        Schedule a child workflow.

        Returns:
        - `Completed` if child already completed during replay
        - `Failed` if child already failed during replay
        - `Pending` if child is new or not yet completed
        """

        raise NotImplementedError
    def schedule_task(self, kind: "str",input: "bytes",queue: "typing.Optional[str]",timeout_ms: "typing.Optional[int]"):
        """
        Schedule a task for execution.

        Returns:
        - `Completed` if task already completed during replay
        - `Failed` if task already failed during replay
        - `Pending` if task is new or not yet completed
        """

        raise NotImplementedError
    def set_state(self, key: "str",value: "bytes"):
        """
        Set workflow state.
        """

        raise NotImplementedError
    def start_timer(self, duration_ms: "int"):
        """
        Start a timer.

        Returns:
        - `Fired` if timer already fired during replay
        - `Pending` if timer is new or not yet fired
        """

        raise NotImplementedError
    def state_keys(self, ):
        """
        Get all state keys.
        """

        raise NotImplementedError
    def take_commands(self, ):
        """
        Take all generated commands (only new ones, not replayed).

        This drains the command buffer and returns the commands.
        """

        raise NotImplementedError
    def wait_for_signal(self, ):
        """
        Wait for the next signal in the queue.

        Returns:
        - `Received` if a signal is available
        - `Pending` if no signal available - workflow should suspend
        """

        raise NotImplementedError
    def workflow_execution_id(self, ):
        """
        Get the workflow execution ID.
        """

        raise NotImplementedError


class FfiWorkflowContext:
    """
    Replay-aware workflow context for FFI.

    This context handles all replay logic internally:
    - Pre-filters events by type for O(1) lookup
    - Validates determinism during replay
    - Returns cached results for replayed operations
    - Only generates commands for NEW operations
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_free_ffiworkflowcontext, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_clone_ffiworkflowcontext, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def clear_all(self, ) -> None:
        """
        Clear all workflow state.

        Generates ClearState commands for all keys and clears local state.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_clear_all,self._uniffi_clone_pointer(),)






    def clear_state(self, key: "str") -> None:
        """
        Clear workflow state.
        """

        _UniffiConverterString.check_lower(key)
        
        _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_clear_state,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key))






    def command_count(self, ) -> "int":
        """
        Get the number of pending commands.
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_command_count,self._uniffi_clone_pointer(),)
        )





    def create_promise(self, name: "str",timeout_ms: "typing.Optional[int]") -> "FfiPromiseResult":
        """
        Create a durable promise.

        Returns:
        - `Resolved` if promise already resolved during replay
        - `Rejected` if promise already rejected during replay
        - `TimedOut` if promise already timed out during replay
        - `Pending` if promise is new or not yet resolved
        """

        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterOptionalInt64.check_lower(timeout_ms)
        
        return _UniffiConverterTypeFfiPromiseResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_create_promise,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name),
        _UniffiConverterOptionalInt64.lower(timeout_ms))
        )





    def current_time_millis(self, ) -> "int":
        """
        Get the current time in milliseconds since Unix epoch.

        This returns a deterministic value that is the same across replays.
        """

        return _UniffiConverterInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_current_time_millis,self._uniffi_clone_pointer(),)
        )





    def drain_signals(self, ) -> "typing.List[FfiSignalEvent]":
        """
        Drain all pending signals from the queue.
        """

        return _UniffiConverterSequenceTypeFfiSignalEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_drain_signals,self._uniffi_clone_pointer(),)
        )





    def get_state(self, key: "str") -> "typing.Optional[bytes]":
        """
        Get workflow state.
        """

        _UniffiConverterString.check_lower(key)
        
        return _UniffiConverterOptionalBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_get_state,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key))
        )





    def has_signal(self, ) -> "bool":
        """
        Check if any signals are pending in the queue.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_has_signal,self._uniffi_clone_pointer(),)
        )





    def is_cancellation_requested(self, ) -> "bool":
        """
        Check if cancellation has been requested.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_is_cancellation_requested,self._uniffi_clone_pointer(),)
        )





    def pending_signal_count(self, ) -> "int":
        """
        Get the number of pending signals.
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_pending_signal_count,self._uniffi_clone_pointer(),)
        )





    def random(self, ) -> "float":
        """
        Generate a deterministic random number in [0, 1).
        """

        return _UniffiConverterDouble.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_random,self._uniffi_clone_pointer(),)
        )





    def random_uuid(self, ) -> "str":
        """
        Generate a deterministic UUID.

        Each call returns a new UUID that is the same across replays.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_random_uuid,self._uniffi_clone_pointer(),)
        )





    def record_operation_result(self, name: "str",result: "bytes") -> None:
        """
        Record the result of an operation that was executed.
        """

        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterBytes.check_lower(result)
        
        _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_record_operation_result,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name),
        _UniffiConverterBytes.lower(result))






    def request_cancellation(self, ) -> None:
        """
        Request cancellation (called when CancelWorkflow job is received).
        """

        _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_request_cancellation,self._uniffi_clone_pointer(),)






    def run_operation(self, name: "str") -> "FfiOperationResult":
        """
        Run a side effect operation.

        Returns:
        - `Cached` if operation already executed during replay
        - `Execute` if operation is new and should be executed
        """

        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeFfiOperationResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_run_operation,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name))
        )





    def schedule_child_workflow(self, name: "str",kind: "typing.Optional[str]",input: "bytes",queue: "typing.Optional[str]",priority_seconds: "typing.Optional[int]") -> "FfiChildWorkflowResult":
        """
        Schedule a child workflow.

        Returns:
        - `Completed` if child already completed during replay
        - `Failed` if child already failed during replay
        - `Pending` if child is new or not yet completed
        """

        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterOptionalString.check_lower(kind)
        
        _UniffiConverterBytes.check_lower(input)
        
        _UniffiConverterOptionalString.check_lower(queue)
        
        _UniffiConverterOptionalInt32.check_lower(priority_seconds)
        
        return _UniffiConverterTypeFfiChildWorkflowResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_schedule_child_workflow,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name),
        _UniffiConverterOptionalString.lower(kind),
        _UniffiConverterBytes.lower(input),
        _UniffiConverterOptionalString.lower(queue),
        _UniffiConverterOptionalInt32.lower(priority_seconds))
        )





    def schedule_task(self, kind: "str",input: "bytes",queue: "typing.Optional[str]",timeout_ms: "typing.Optional[int]") -> "FfiTaskResult":
        """
        Schedule a task for execution.

        Returns:
        - `Completed` if task already completed during replay
        - `Failed` if task already failed during replay
        - `Pending` if task is new or not yet completed
        """

        _UniffiConverterString.check_lower(kind)
        
        _UniffiConverterBytes.check_lower(input)
        
        _UniffiConverterOptionalString.check_lower(queue)
        
        _UniffiConverterOptionalInt64.check_lower(timeout_ms)
        
        return _UniffiConverterTypeFfiTaskResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_schedule_task,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(kind),
        _UniffiConverterBytes.lower(input),
        _UniffiConverterOptionalString.lower(queue),
        _UniffiConverterOptionalInt64.lower(timeout_ms))
        )





    def set_state(self, key: "str",value: "bytes") -> None:
        """
        Set workflow state.
        """

        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterBytes.check_lower(value)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_set_state,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(key),
        _UniffiConverterBytes.lower(value))






    def start_timer(self, duration_ms: "int") -> "FfiTimerResult":
        """
        Start a timer.

        Returns:
        - `Fired` if timer already fired during replay
        - `Pending` if timer is new or not yet fired
        """

        _UniffiConverterInt64.check_lower(duration_ms)
        
        return _UniffiConverterTypeFfiTimerResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeFfiError,_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_start_timer,self._uniffi_clone_pointer(),
        _UniffiConverterInt64.lower(duration_ms))
        )





    def state_keys(self, ) -> "typing.List[str]":
        """
        Get all state keys.
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_state_keys,self._uniffi_clone_pointer(),)
        )





    def take_commands(self, ) -> "typing.List[FfiWorkflowCommand]":
        """
        Take all generated commands (only new ones, not replayed).

        This drains the command buffer and returns the commands.
        """

        return _UniffiConverterSequenceTypeFfiWorkflowCommand.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_take_commands,self._uniffi_clone_pointer(),)
        )





    def wait_for_signal(self, ) -> "FfiSignalResult":
        """
        Wait for the next signal in the queue.

        Returns:
        - `Received` if a signal is available
        - `Pending` if no signal available - workflow should suspend
        """

        return _UniffiConverterTypeFfiSignalResult.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_wait_for_signal,self._uniffi_clone_pointer(),)
        )





    def workflow_execution_id(self, ) -> "str":
        """
        Get the workflow execution ID.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_flovyn_worker_ffi_fn_method_ffiworkflowcontext_workflow_execution_id,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFfiWorkflowContext:

    @staticmethod
    def lift(value: int):
        return FfiWorkflowContext._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiWorkflowContext):
        if not isinstance(value, FfiWorkflowContext):
            raise TypeError("Expected FfiWorkflowContext instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiWorkflowContextProtocol):
        if not isinstance(value, FfiWorkflowContext):
            raise TypeError("Expected FfiWorkflowContext instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiWorkflowContextProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class ClientConfig:
    """
    Configuration for creating a CoreClient.
    """

    server_url: "str"
    """
    Server URL (e.g., `http://localhost:9090`).
    """

    client_token: "typing.Optional[str]"
    """
    Client token for authentication (should start with "fct_").
    If not provided, a placeholder will be used.
    Ignored if oauth2_credentials is provided.
    """

    oauth2_credentials: "typing.Optional[OAuth2Credentials]"
    """
    OAuth2 client credentials for authentication.
    If provided, the SDK will fetch a JWT using client credentials flow.
    """

    org_id: "str"
    """
    Org ID (UUID format) for operations.
    """

    def __init__(self, *, server_url: "str", client_token: "typing.Optional[str]", oauth2_credentials: "typing.Optional[OAuth2Credentials]", org_id: "str"):
        self.server_url = server_url
        self.client_token = client_token
        self.oauth2_credentials = oauth2_credentials
        self.org_id = org_id

    def __str__(self):
        return "ClientConfig(server_url={}, client_token={}, oauth2_credentials={}, org_id={})".format(self.server_url, self.client_token, self.oauth2_credentials, self.org_id)

    def __eq__(self, other):
        if self.server_url != other.server_url:
            return False
        if self.client_token != other.client_token:
            return False
        if self.oauth2_credentials != other.oauth2_credentials:
            return False
        if self.org_id != other.org_id:
            return False
        return True

class _UniffiConverterTypeClientConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientConfig(
            server_url=_UniffiConverterString.read(buf),
            client_token=_UniffiConverterOptionalString.read(buf),
            oauth2_credentials=_UniffiConverterOptionalTypeOAuth2Credentials.read(buf),
            org_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.server_url)
        _UniffiConverterOptionalString.check_lower(value.client_token)
        _UniffiConverterOptionalTypeOAuth2Credentials.check_lower(value.oauth2_credentials)
        _UniffiConverterString.check_lower(value.org_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.server_url, buf)
        _UniffiConverterOptionalString.write(value.client_token, buf)
        _UniffiConverterOptionalTypeOAuth2Credentials.write(value.oauth2_credentials, buf)
        _UniffiConverterString.write(value.org_id, buf)


class FfiConnectionInfo:
    """
    Connection information for FFI.
    """

    connected: "bool"
    """
    Whether currently connected.
    """

    last_heartbeat_ms: "typing.Optional[int]"
    """
    Time of last successful heartbeat (ms since epoch, if any).
    """

    last_poll_ms: "typing.Optional[int]"
    """
    Time of last successful poll (ms since epoch, if any).
    """

    heartbeat_failures: "int"
    """
    Number of consecutive heartbeat failures.
    """

    poll_failures: "int"
    """
    Number of consecutive poll failures.
    """

    reconnect_attempt: "typing.Optional[int]"
    """
    Current reconnection attempt (if reconnecting).
    """

    def __init__(self, *, connected: "bool", last_heartbeat_ms: "typing.Optional[int]", last_poll_ms: "typing.Optional[int]", heartbeat_failures: "int", poll_failures: "int", reconnect_attempt: "typing.Optional[int]"):
        self.connected = connected
        self.last_heartbeat_ms = last_heartbeat_ms
        self.last_poll_ms = last_poll_ms
        self.heartbeat_failures = heartbeat_failures
        self.poll_failures = poll_failures
        self.reconnect_attempt = reconnect_attempt

    def __str__(self):
        return "FfiConnectionInfo(connected={}, last_heartbeat_ms={}, last_poll_ms={}, heartbeat_failures={}, poll_failures={}, reconnect_attempt={})".format(self.connected, self.last_heartbeat_ms, self.last_poll_ms, self.heartbeat_failures, self.poll_failures, self.reconnect_attempt)

    def __eq__(self, other):
        if self.connected != other.connected:
            return False
        if self.last_heartbeat_ms != other.last_heartbeat_ms:
            return False
        if self.last_poll_ms != other.last_poll_ms:
            return False
        if self.heartbeat_failures != other.heartbeat_failures:
            return False
        if self.poll_failures != other.poll_failures:
            return False
        if self.reconnect_attempt != other.reconnect_attempt:
            return False
        return True

class _UniffiConverterTypeFfiConnectionInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiConnectionInfo(
            connected=_UniffiConverterBool.read(buf),
            last_heartbeat_ms=_UniffiConverterOptionalInt64.read(buf),
            last_poll_ms=_UniffiConverterOptionalInt64.read(buf),
            heartbeat_failures=_UniffiConverterUInt32.read(buf),
            poll_failures=_UniffiConverterUInt32.read(buf),
            reconnect_attempt=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.connected)
        _UniffiConverterOptionalInt64.check_lower(value.last_heartbeat_ms)
        _UniffiConverterOptionalInt64.check_lower(value.last_poll_ms)
        _UniffiConverterUInt32.check_lower(value.heartbeat_failures)
        _UniffiConverterUInt32.check_lower(value.poll_failures)
        _UniffiConverterOptionalUInt32.check_lower(value.reconnect_attempt)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.connected, buf)
        _UniffiConverterOptionalInt64.write(value.last_heartbeat_ms, buf)
        _UniffiConverterOptionalInt64.write(value.last_poll_ms, buf)
        _UniffiConverterUInt32.write(value.heartbeat_failures, buf)
        _UniffiConverterUInt32.write(value.poll_failures, buf)
        _UniffiConverterOptionalUInt32.write(value.reconnect_attempt, buf)


class FfiRegistrationInfo:
    """
    Registration information for FFI.
    """

    worker_id: "str"
    """
    Server-assigned worker ID.
    """

    success: "bool"
    """
    Whether registration was successful.
    """

    registered_at_ms: "int"
    """
    When the worker was registered (ms since epoch).
    """

    workflow_kinds: "typing.List[str]"
    """
    Registered workflow kinds.
    """

    task_kinds: "typing.List[str]"
    """
    Registered task kinds.
    """

    has_conflicts: "bool"
    """
    Whether there are any registration conflicts.
    """

    def __init__(self, *, worker_id: "str", success: "bool", registered_at_ms: "int", workflow_kinds: "typing.List[str]", task_kinds: "typing.List[str]", has_conflicts: "bool"):
        self.worker_id = worker_id
        self.success = success
        self.registered_at_ms = registered_at_ms
        self.workflow_kinds = workflow_kinds
        self.task_kinds = task_kinds
        self.has_conflicts = has_conflicts

    def __str__(self):
        return "FfiRegistrationInfo(worker_id={}, success={}, registered_at_ms={}, workflow_kinds={}, task_kinds={}, has_conflicts={})".format(self.worker_id, self.success, self.registered_at_ms, self.workflow_kinds, self.task_kinds, self.has_conflicts)

    def __eq__(self, other):
        if self.worker_id != other.worker_id:
            return False
        if self.success != other.success:
            return False
        if self.registered_at_ms != other.registered_at_ms:
            return False
        if self.workflow_kinds != other.workflow_kinds:
            return False
        if self.task_kinds != other.task_kinds:
            return False
        if self.has_conflicts != other.has_conflicts:
            return False
        return True

class _UniffiConverterTypeFfiRegistrationInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiRegistrationInfo(
            worker_id=_UniffiConverterString.read(buf),
            success=_UniffiConverterBool.read(buf),
            registered_at_ms=_UniffiConverterInt64.read(buf),
            workflow_kinds=_UniffiConverterSequenceString.read(buf),
            task_kinds=_UniffiConverterSequenceString.read(buf),
            has_conflicts=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.worker_id)
        _UniffiConverterBool.check_lower(value.success)
        _UniffiConverterInt64.check_lower(value.registered_at_ms)
        _UniffiConverterSequenceString.check_lower(value.workflow_kinds)
        _UniffiConverterSequenceString.check_lower(value.task_kinds)
        _UniffiConverterBool.check_lower(value.has_conflicts)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.worker_id, buf)
        _UniffiConverterBool.write(value.success, buf)
        _UniffiConverterInt64.write(value.registered_at_ms, buf)
        _UniffiConverterSequenceString.write(value.workflow_kinds, buf)
        _UniffiConverterSequenceString.write(value.task_kinds, buf)
        _UniffiConverterBool.write(value.has_conflicts, buf)


class FfiReplayEvent:
    """
    Replay event for FFI.
    """

    sequence_number: "int"
    """
    Sequence number of this event (1-indexed).
    """

    event_type: "FfiEventType"
    """
    Type of the event.
    """

    data: "bytes"
    """
    Event data as JSON bytes.
    """

    timestamp_ms: "int"
    """
    Timestamp in milliseconds since Unix epoch.
    """

    def __init__(self, *, sequence_number: "int", event_type: "FfiEventType", data: "bytes", timestamp_ms: "int"):
        self.sequence_number = sequence_number
        self.event_type = event_type
        self.data = data
        self.timestamp_ms = timestamp_ms

    def __str__(self):
        return "FfiReplayEvent(sequence_number={}, event_type={}, data={}, timestamp_ms={})".format(self.sequence_number, self.event_type, self.data, self.timestamp_ms)

    def __eq__(self, other):
        if self.sequence_number != other.sequence_number:
            return False
        if self.event_type != other.event_type:
            return False
        if self.data != other.data:
            return False
        if self.timestamp_ms != other.timestamp_ms:
            return False
        return True

class _UniffiConverterTypeFfiReplayEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiReplayEvent(
            sequence_number=_UniffiConverterInt32.read(buf),
            event_type=_UniffiConverterTypeFfiEventType.read(buf),
            data=_UniffiConverterBytes.read(buf),
            timestamp_ms=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.sequence_number)
        _UniffiConverterTypeFfiEventType.check_lower(value.event_type)
        _UniffiConverterBytes.check_lower(value.data)
        _UniffiConverterInt64.check_lower(value.timestamp_ms)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.sequence_number, buf)
        _UniffiConverterTypeFfiEventType.write(value.event_type, buf)
        _UniffiConverterBytes.write(value.data, buf)
        _UniffiConverterInt64.write(value.timestamp_ms, buf)


class FfiSignalEvent:
    """
    A signal event from the signal queue.
    """

    signal_name: "str"
    """
    Signal name.
    """

    value: "bytes"
    """
    Serialized value as JSON bytes.
    """

    def __init__(self, *, signal_name: "str", value: "bytes"):
        self.signal_name = signal_name
        self.value = value

    def __str__(self):
        return "FfiSignalEvent(signal_name={}, value={})".format(self.signal_name, self.value)

    def __eq__(self, other):
        if self.signal_name != other.signal_name:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeFfiSignalEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiSignalEvent(
            signal_name=_UniffiConverterString.read(buf),
            value=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.signal_name)
        _UniffiConverterBytes.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.signal_name, buf)
        _UniffiConverterBytes.write(value.value, buf)


class LifecycleEvent:
    """
    Lifecycle event for worker status changes.
    """

    event_name: "str"
    """
    Event name (e.g., "starting", "registered", "ready", "paused", "resumed", "stopped")
    """

    timestamp_ms: "int"
    """
    Timestamp in milliseconds since Unix epoch
    """

    data: "typing.Optional[str]"
    """
    Optional additional data as JSON string
    """

    def __init__(self, *, event_name: "str", timestamp_ms: "int", data: "typing.Optional[str]"):
        self.event_name = event_name
        self.timestamp_ms = timestamp_ms
        self.data = data

    def __str__(self):
        return "LifecycleEvent(event_name={}, timestamp_ms={}, data={})".format(self.event_name, self.timestamp_ms, self.data)

    def __eq__(self, other):
        if self.event_name != other.event_name:
            return False
        if self.timestamp_ms != other.timestamp_ms:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeLifecycleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LifecycleEvent(
            event_name=_UniffiConverterString.read(buf),
            timestamp_ms=_UniffiConverterInt64.read(buf),
            data=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.event_name)
        _UniffiConverterInt64.check_lower(value.timestamp_ms)
        _UniffiConverterOptionalString.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.event_name, buf)
        _UniffiConverterInt64.write(value.timestamp_ms, buf)
        _UniffiConverterOptionalString.write(value.data, buf)


class OAuth2Credentials:
    """
    OAuth2 client credentials for authentication.
    """

    client_id: "str"
    """
    OAuth2 client ID.
    """

    client_secret: "str"
    """
    OAuth2 client secret.
    """

    token_endpoint: "str"
    """
    Token endpoint URL (e.g., `https://keycloak.example.com/realms/myrealm/protocol/openid-connect/token`).
    """

    scopes: "typing.Optional[str]"
    """
    Optional scopes (space-separated if multiple).
    """

    def __init__(self, *, client_id: "str", client_secret: "str", token_endpoint: "str", scopes: "typing.Optional[str]"):
        self.client_id = client_id
        self.client_secret = client_secret
        self.token_endpoint = token_endpoint
        self.scopes = scopes

    def __str__(self):
        return "OAuth2Credentials(client_id={}, client_secret={}, token_endpoint={}, scopes={})".format(self.client_id, self.client_secret, self.token_endpoint, self.scopes)

    def __eq__(self, other):
        if self.client_id != other.client_id:
            return False
        if self.client_secret != other.client_secret:
            return False
        if self.token_endpoint != other.token_endpoint:
            return False
        if self.scopes != other.scopes:
            return False
        return True

class _UniffiConverterTypeOAuth2Credentials(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OAuth2Credentials(
            client_id=_UniffiConverterString.read(buf),
            client_secret=_UniffiConverterString.read(buf),
            token_endpoint=_UniffiConverterString.read(buf),
            scopes=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.client_id)
        _UniffiConverterString.check_lower(value.client_secret)
        _UniffiConverterString.check_lower(value.token_endpoint)
        _UniffiConverterOptionalString.check_lower(value.scopes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.client_id, buf)
        _UniffiConverterString.write(value.client_secret, buf)
        _UniffiConverterString.write(value.token_endpoint, buf)
        _UniffiConverterOptionalString.write(value.scopes, buf)


class SignalWithStartResponse:
    """
    Result of signal-with-start operation.
    """

    workflow_execution_id: "str"
    """
    The workflow execution ID.
    """

    workflow_created: "bool"
    """
    Whether the workflow was created (vs already existed).
    """

    signal_event_sequence: "int"
    """
    Sequence number of the signal event.
    """

    def __init__(self, *, workflow_execution_id: "str", workflow_created: "bool", signal_event_sequence: "int"):
        self.workflow_execution_id = workflow_execution_id
        self.workflow_created = workflow_created
        self.signal_event_sequence = signal_event_sequence

    def __str__(self):
        return "SignalWithStartResponse(workflow_execution_id={}, workflow_created={}, signal_event_sequence={})".format(self.workflow_execution_id, self.workflow_created, self.signal_event_sequence)

    def __eq__(self, other):
        if self.workflow_execution_id != other.workflow_execution_id:
            return False
        if self.workflow_created != other.workflow_created:
            return False
        if self.signal_event_sequence != other.signal_event_sequence:
            return False
        return True

class _UniffiConverterTypeSignalWithStartResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignalWithStartResponse(
            workflow_execution_id=_UniffiConverterString.read(buf),
            workflow_created=_UniffiConverterBool.read(buf),
            signal_event_sequence=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.workflow_execution_id)
        _UniffiConverterBool.check_lower(value.workflow_created)
        _UniffiConverterInt64.check_lower(value.signal_event_sequence)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.workflow_execution_id, buf)
        _UniffiConverterBool.write(value.workflow_created, buf)
        _UniffiConverterInt64.write(value.signal_event_sequence, buf)


class SignalWorkflowResponse:
    """
    Result of signaling a workflow.
    """

    signal_event_sequence: "int"
    """
    Sequence number of the signal event.
    """

    def __init__(self, *, signal_event_sequence: "int"):
        self.signal_event_sequence = signal_event_sequence

    def __str__(self):
        return "SignalWorkflowResponse(signal_event_sequence={})".format(self.signal_event_sequence)

    def __eq__(self, other):
        if self.signal_event_sequence != other.signal_event_sequence:
            return False
        return True

class _UniffiConverterTypeSignalWorkflowResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignalWorkflowResponse(
            signal_event_sequence=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.signal_event_sequence)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.signal_event_sequence, buf)


class StartWorkflowResponse:
    """
    Result of starting a workflow.
    """

    workflow_execution_id: "str"
    """
    The workflow execution ID.
    """

    idempotency_key_used: "bool"
    """
    Whether an idempotency key was used.
    """

    idempotency_key_new: "bool"
    """
    Whether this is a new execution (false means existing was returned).
    """

    def __init__(self, *, workflow_execution_id: "str", idempotency_key_used: "bool", idempotency_key_new: "bool"):
        self.workflow_execution_id = workflow_execution_id
        self.idempotency_key_used = idempotency_key_used
        self.idempotency_key_new = idempotency_key_new

    def __str__(self):
        return "StartWorkflowResponse(workflow_execution_id={}, idempotency_key_used={}, idempotency_key_new={})".format(self.workflow_execution_id, self.idempotency_key_used, self.idempotency_key_new)

    def __eq__(self, other):
        if self.workflow_execution_id != other.workflow_execution_id:
            return False
        if self.idempotency_key_used != other.idempotency_key_used:
            return False
        if self.idempotency_key_new != other.idempotency_key_new:
            return False
        return True

class _UniffiConverterTypeStartWorkflowResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StartWorkflowResponse(
            workflow_execution_id=_UniffiConverterString.read(buf),
            idempotency_key_used=_UniffiConverterBool.read(buf),
            idempotency_key_new=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.workflow_execution_id)
        _UniffiConverterBool.check_lower(value.idempotency_key_used)
        _UniffiConverterBool.check_lower(value.idempotency_key_new)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.workflow_execution_id, buf)
        _UniffiConverterBool.write(value.idempotency_key_used, buf)
        _UniffiConverterBool.write(value.idempotency_key_new, buf)


class StateEntry:
    """
    A key-value pair for workflow state.
    """

    key: "str"
    """
    State key.
    """

    value: "bytes"
    """
    Serialized value as JSON bytes.
    """

    def __init__(self, *, key: "str", value: "bytes"):
        self.key = key
        self.value = value

    def __str__(self):
        return "StateEntry(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeStateEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateEntry(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterBytes.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterBytes.write(value.value, buf)


class TaskActivation:
    """
    A task activation containing work for the language SDK to process.
    """

    context: "FfiTaskContext"
    """
    The task context for streaming and lifecycle APIs.

    Use this context to stream tokens, progress, data, and errors.
    Also provides access to task metadata like attempt number.
    """

    task_execution_id: "str"
    """
    The task execution ID.
    """

    task_kind: "str"
    """
    The task kind/type.
    """

    input: "bytes"
    """
    Serialized task input as JSON bytes.
    """

    workflow_execution_id: "typing.Optional[str]"
    """
    Workflow execution ID that scheduled this task (if any).
    """

    attempt: "int"
    """
    Current attempt number (1-based).
    """

    max_retries: "int"
    """
    Maximum number of retries.
    """

    timeout_ms: "typing.Optional[int]"
    """
    Timeout in milliseconds (if set).
    """

    def __init__(self, *, context: "FfiTaskContext", task_execution_id: "str", task_kind: "str", input: "bytes", workflow_execution_id: "typing.Optional[str]", attempt: "int", max_retries: "int", timeout_ms: "typing.Optional[int]"):
        self.context = context
        self.task_execution_id = task_execution_id
        self.task_kind = task_kind
        self.input = input
        self.workflow_execution_id = workflow_execution_id
        self.attempt = attempt
        self.max_retries = max_retries
        self.timeout_ms = timeout_ms

    def __str__(self):
        return "TaskActivation(context={}, task_execution_id={}, task_kind={}, input={}, workflow_execution_id={}, attempt={}, max_retries={}, timeout_ms={})".format(self.context, self.task_execution_id, self.task_kind, self.input, self.workflow_execution_id, self.attempt, self.max_retries, self.timeout_ms)

    def __eq__(self, other):
        if self.context != other.context:
            return False
        if self.task_execution_id != other.task_execution_id:
            return False
        if self.task_kind != other.task_kind:
            return False
        if self.input != other.input:
            return False
        if self.workflow_execution_id != other.workflow_execution_id:
            return False
        if self.attempt != other.attempt:
            return False
        if self.max_retries != other.max_retries:
            return False
        if self.timeout_ms != other.timeout_ms:
            return False
        return True

class _UniffiConverterTypeTaskActivation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TaskActivation(
            context=_UniffiConverterTypeFfiTaskContext.read(buf),
            task_execution_id=_UniffiConverterString.read(buf),
            task_kind=_UniffiConverterString.read(buf),
            input=_UniffiConverterBytes.read(buf),
            workflow_execution_id=_UniffiConverterOptionalString.read(buf),
            attempt=_UniffiConverterUInt32.read(buf),
            max_retries=_UniffiConverterUInt32.read(buf),
            timeout_ms=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiTaskContext.check_lower(value.context)
        _UniffiConverterString.check_lower(value.task_execution_id)
        _UniffiConverterString.check_lower(value.task_kind)
        _UniffiConverterBytes.check_lower(value.input)
        _UniffiConverterOptionalString.check_lower(value.workflow_execution_id)
        _UniffiConverterUInt32.check_lower(value.attempt)
        _UniffiConverterUInt32.check_lower(value.max_retries)
        _UniffiConverterOptionalInt64.check_lower(value.timeout_ms)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiTaskContext.write(value.context, buf)
        _UniffiConverterString.write(value.task_execution_id, buf)
        _UniffiConverterString.write(value.task_kind, buf)
        _UniffiConverterBytes.write(value.input, buf)
        _UniffiConverterOptionalString.write(value.workflow_execution_id, buf)
        _UniffiConverterUInt32.write(value.attempt, buf)
        _UniffiConverterUInt32.write(value.max_retries, buf)
        _UniffiConverterOptionalInt64.write(value.timeout_ms, buf)


class TaskMetadataFfi:
    """
    Task metadata passed from Kotlin/Swift to Rust FFI.
    """

    kind: "str"
    """
    Unique task kind identifier (required).
    """

    name: "str"
    """
    Human-readable name (defaults to kind if empty).
    """

    description: "typing.Optional[str]"
    """
    Optional description.
    """

    version: "typing.Optional[str]"
    """
    Version string (e.g., "1.0.0").
    """

    tags: "typing.List[str]"
    """
    Tags for categorization.
    """

    cancellable: "bool"
    """
    Whether the task can be cancelled.
    """

    timeout_seconds: "typing.Optional[int]"
    """
    Timeout in seconds.
    """

    input_schema: "typing.Optional[str]"
    """
    JSON Schema for input validation (JSON string).
    """

    output_schema: "typing.Optional[str]"
    """
    JSON Schema for output validation (JSON string).
    """

    def __init__(self, *, kind: "str", name: "str", description: "typing.Optional[str]", version: "typing.Optional[str]", tags: "typing.List[str]", cancellable: "bool", timeout_seconds: "typing.Optional[int]", input_schema: "typing.Optional[str]", output_schema: "typing.Optional[str]"):
        self.kind = kind
        self.name = name
        self.description = description
        self.version = version
        self.tags = tags
        self.cancellable = cancellable
        self.timeout_seconds = timeout_seconds
        self.input_schema = input_schema
        self.output_schema = output_schema

    def __str__(self):
        return "TaskMetadataFfi(kind={}, name={}, description={}, version={}, tags={}, cancellable={}, timeout_seconds={}, input_schema={}, output_schema={})".format(self.kind, self.name, self.description, self.version, self.tags, self.cancellable, self.timeout_seconds, self.input_schema, self.output_schema)

    def __eq__(self, other):
        if self.kind != other.kind:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.version != other.version:
            return False
        if self.tags != other.tags:
            return False
        if self.cancellable != other.cancellable:
            return False
        if self.timeout_seconds != other.timeout_seconds:
            return False
        if self.input_schema != other.input_schema:
            return False
        if self.output_schema != other.output_schema:
            return False
        return True

class _UniffiConverterTypeTaskMetadataFfi(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TaskMetadataFfi(
            kind=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            version=_UniffiConverterOptionalString.read(buf),
            tags=_UniffiConverterSequenceString.read(buf),
            cancellable=_UniffiConverterBool.read(buf),
            timeout_seconds=_UniffiConverterOptionalUInt32.read(buf),
            input_schema=_UniffiConverterOptionalString.read(buf),
            output_schema=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.kind)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.version)
        _UniffiConverterSequenceString.check_lower(value.tags)
        _UniffiConverterBool.check_lower(value.cancellable)
        _UniffiConverterOptionalUInt32.check_lower(value.timeout_seconds)
        _UniffiConverterOptionalString.check_lower(value.input_schema)
        _UniffiConverterOptionalString.check_lower(value.output_schema)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.kind, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.version, buf)
        _UniffiConverterSequenceString.write(value.tags, buf)
        _UniffiConverterBool.write(value.cancellable, buf)
        _UniffiConverterOptionalUInt32.write(value.timeout_seconds, buf)
        _UniffiConverterOptionalString.write(value.input_schema, buf)
        _UniffiConverterOptionalString.write(value.output_schema, buf)


class WorkerConfig:
    """
    Configuration for creating a CoreWorker.
    """

    server_url: "str"
    """
    Server URL (e.g., `http://localhost:9090`).
    """

    worker_token: "typing.Optional[str]"
    """
    Worker token for authentication (should start with "fwt_").
    If not provided or not starting with "fwt_", a placeholder will be used.
    Ignored if oauth2_credentials is provided.
    """

    oauth2_credentials: "typing.Optional[OAuth2Credentials]"
    """
    OAuth2 client credentials for authentication.
    If provided, the SDK will fetch a JWT using client credentials flow.
    """

    org_id: "str"
    """
    Org ID (UUID format) for worker registration.
    """

    queue: "str"
    """
    Task queue to poll for work.
    """

    worker_identity: "typing.Optional[str]"
    """
    Optional worker identity for debugging/monitoring.
    """

    max_concurrent_workflow_tasks: "typing.Optional[int]"
    """
    Maximum concurrent workflow tasks (default: 100).
    """

    max_concurrent_tasks: "typing.Optional[int]"
    """
    Maximum concurrent activity tasks (default: 100).
    """

    workflow_metadata: "typing.List[WorkflowMetadataFfi]"
    """
    Workflow metadata for this worker (replaces workflow_kinds).
    """

    task_metadata: "typing.List[TaskMetadataFfi]"
    """
    Task metadata for this worker (replaces task_kinds).
    """

    def __init__(self, *, server_url: "str", worker_token: "typing.Optional[str]", oauth2_credentials: "typing.Optional[OAuth2Credentials]", org_id: "str", queue: "str", worker_identity: "typing.Optional[str]", max_concurrent_workflow_tasks: "typing.Optional[int]", max_concurrent_tasks: "typing.Optional[int]", workflow_metadata: "typing.List[WorkflowMetadataFfi]", task_metadata: "typing.List[TaskMetadataFfi]"):
        self.server_url = server_url
        self.worker_token = worker_token
        self.oauth2_credentials = oauth2_credentials
        self.org_id = org_id
        self.queue = queue
        self.worker_identity = worker_identity
        self.max_concurrent_workflow_tasks = max_concurrent_workflow_tasks
        self.max_concurrent_tasks = max_concurrent_tasks
        self.workflow_metadata = workflow_metadata
        self.task_metadata = task_metadata

    def __str__(self):
        return "WorkerConfig(server_url={}, worker_token={}, oauth2_credentials={}, org_id={}, queue={}, worker_identity={}, max_concurrent_workflow_tasks={}, max_concurrent_tasks={}, workflow_metadata={}, task_metadata={})".format(self.server_url, self.worker_token, self.oauth2_credentials, self.org_id, self.queue, self.worker_identity, self.max_concurrent_workflow_tasks, self.max_concurrent_tasks, self.workflow_metadata, self.task_metadata)

    def __eq__(self, other):
        if self.server_url != other.server_url:
            return False
        if self.worker_token != other.worker_token:
            return False
        if self.oauth2_credentials != other.oauth2_credentials:
            return False
        if self.org_id != other.org_id:
            return False
        if self.queue != other.queue:
            return False
        if self.worker_identity != other.worker_identity:
            return False
        if self.max_concurrent_workflow_tasks != other.max_concurrent_workflow_tasks:
            return False
        if self.max_concurrent_tasks != other.max_concurrent_tasks:
            return False
        if self.workflow_metadata != other.workflow_metadata:
            return False
        if self.task_metadata != other.task_metadata:
            return False
        return True

class _UniffiConverterTypeWorkerConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WorkerConfig(
            server_url=_UniffiConverterString.read(buf),
            worker_token=_UniffiConverterOptionalString.read(buf),
            oauth2_credentials=_UniffiConverterOptionalTypeOAuth2Credentials.read(buf),
            org_id=_UniffiConverterString.read(buf),
            queue=_UniffiConverterString.read(buf),
            worker_identity=_UniffiConverterOptionalString.read(buf),
            max_concurrent_workflow_tasks=_UniffiConverterOptionalUInt32.read(buf),
            max_concurrent_tasks=_UniffiConverterOptionalUInt32.read(buf),
            workflow_metadata=_UniffiConverterSequenceTypeWorkflowMetadataFfi.read(buf),
            task_metadata=_UniffiConverterSequenceTypeTaskMetadataFfi.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.server_url)
        _UniffiConverterOptionalString.check_lower(value.worker_token)
        _UniffiConverterOptionalTypeOAuth2Credentials.check_lower(value.oauth2_credentials)
        _UniffiConverterString.check_lower(value.org_id)
        _UniffiConverterString.check_lower(value.queue)
        _UniffiConverterOptionalString.check_lower(value.worker_identity)
        _UniffiConverterOptionalUInt32.check_lower(value.max_concurrent_workflow_tasks)
        _UniffiConverterOptionalUInt32.check_lower(value.max_concurrent_tasks)
        _UniffiConverterSequenceTypeWorkflowMetadataFfi.check_lower(value.workflow_metadata)
        _UniffiConverterSequenceTypeTaskMetadataFfi.check_lower(value.task_metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.server_url, buf)
        _UniffiConverterOptionalString.write(value.worker_token, buf)
        _UniffiConverterOptionalTypeOAuth2Credentials.write(value.oauth2_credentials, buf)
        _UniffiConverterString.write(value.org_id, buf)
        _UniffiConverterString.write(value.queue, buf)
        _UniffiConverterOptionalString.write(value.worker_identity, buf)
        _UniffiConverterOptionalUInt32.write(value.max_concurrent_workflow_tasks, buf)
        _UniffiConverterOptionalUInt32.write(value.max_concurrent_tasks, buf)
        _UniffiConverterSequenceTypeWorkflowMetadataFfi.write(value.workflow_metadata, buf)
        _UniffiConverterSequenceTypeTaskMetadataFfi.write(value.task_metadata, buf)


class WorkerMetrics:
    """
    Worker metrics for FFI.
    """

    uptime_ms: "int"
    """
    Uptime in milliseconds.
    """

    status: "str"
    """
    Current worker status.
    """

    worker_id: "typing.Optional[str]"
    """
    Server-assigned worker ID (if registered).
    """

    workflows_processed: "int"
    """
    Total workflows processed.
    """

    tasks_processed: "int"
    """
    Total tasks processed.
    """

    active_workflows: "int"
    """
    Currently active workflows.
    """

    active_tasks: "int"
    """
    Currently active tasks.
    """

    def __init__(self, *, uptime_ms: "int", status: "str", worker_id: "typing.Optional[str]", workflows_processed: "int", tasks_processed: "int", active_workflows: "int", active_tasks: "int"):
        self.uptime_ms = uptime_ms
        self.status = status
        self.worker_id = worker_id
        self.workflows_processed = workflows_processed
        self.tasks_processed = tasks_processed
        self.active_workflows = active_workflows
        self.active_tasks = active_tasks

    def __str__(self):
        return "WorkerMetrics(uptime_ms={}, status={}, worker_id={}, workflows_processed={}, tasks_processed={}, active_workflows={}, active_tasks={})".format(self.uptime_ms, self.status, self.worker_id, self.workflows_processed, self.tasks_processed, self.active_workflows, self.active_tasks)

    def __eq__(self, other):
        if self.uptime_ms != other.uptime_ms:
            return False
        if self.status != other.status:
            return False
        if self.worker_id != other.worker_id:
            return False
        if self.workflows_processed != other.workflows_processed:
            return False
        if self.tasks_processed != other.tasks_processed:
            return False
        if self.active_workflows != other.active_workflows:
            return False
        if self.active_tasks != other.active_tasks:
            return False
        return True

class _UniffiConverterTypeWorkerMetrics(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WorkerMetrics(
            uptime_ms=_UniffiConverterInt64.read(buf),
            status=_UniffiConverterString.read(buf),
            worker_id=_UniffiConverterOptionalString.read(buf),
            workflows_processed=_UniffiConverterUInt64.read(buf),
            tasks_processed=_UniffiConverterUInt64.read(buf),
            active_workflows=_UniffiConverterUInt32.read(buf),
            active_tasks=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.uptime_ms)
        _UniffiConverterString.check_lower(value.status)
        _UniffiConverterOptionalString.check_lower(value.worker_id)
        _UniffiConverterUInt64.check_lower(value.workflows_processed)
        _UniffiConverterUInt64.check_lower(value.tasks_processed)
        _UniffiConverterUInt32.check_lower(value.active_workflows)
        _UniffiConverterUInt32.check_lower(value.active_tasks)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.uptime_ms, buf)
        _UniffiConverterString.write(value.status, buf)
        _UniffiConverterOptionalString.write(value.worker_id, buf)
        _UniffiConverterUInt64.write(value.workflows_processed, buf)
        _UniffiConverterUInt64.write(value.tasks_processed, buf)
        _UniffiConverterUInt32.write(value.active_workflows, buf)
        _UniffiConverterUInt32.write(value.active_tasks, buf)


class WorkflowActivation:
    """
    A workflow activation containing work for the language SDK to process.

    The activation includes a replay-aware context that handles:
    - Determinism validation during replay
    - Cached result return for replayed operations
    - Command generation for new operations

    Activations are returned by `CoreWorker::poll_workflow_activation()`.
    """

    context: "FfiWorkflowContext"
    """
    The replay-aware workflow context.

    Use this context to call workflow operations like `schedule_task()`,
    `create_promise()`, `start_timer()`, etc. The context handles replay
    automatically and returns cached results during replay.
    """

    workflow_kind: "str"
    """
    The workflow kind/type.
    """

    input: "bytes"
    """
    Serialized workflow input as JSON bytes.
    """

    jobs: "typing.List[WorkflowActivationJob]"
    """
    Jobs to process in this activation.

    Jobs include signals, queries, and cancellation requests that
    don't go through the context replay mechanism.
    """

    def __init__(self, *, context: "FfiWorkflowContext", workflow_kind: "str", input: "bytes", jobs: "typing.List[WorkflowActivationJob]"):
        self.context = context
        self.workflow_kind = workflow_kind
        self.input = input
        self.jobs = jobs

    def __str__(self):
        return "WorkflowActivation(context={}, workflow_kind={}, input={}, jobs={})".format(self.context, self.workflow_kind, self.input, self.jobs)

    def __eq__(self, other):
        if self.context != other.context:
            return False
        if self.workflow_kind != other.workflow_kind:
            return False
        if self.input != other.input:
            return False
        if self.jobs != other.jobs:
            return False
        return True

class _UniffiConverterTypeWorkflowActivation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WorkflowActivation(
            context=_UniffiConverterTypeFfiWorkflowContext.read(buf),
            workflow_kind=_UniffiConverterString.read(buf),
            input=_UniffiConverterBytes.read(buf),
            jobs=_UniffiConverterSequenceTypeWorkflowActivationJob.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiWorkflowContext.check_lower(value.context)
        _UniffiConverterString.check_lower(value.workflow_kind)
        _UniffiConverterBytes.check_lower(value.input)
        _UniffiConverterSequenceTypeWorkflowActivationJob.check_lower(value.jobs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiWorkflowContext.write(value.context, buf)
        _UniffiConverterString.write(value.workflow_kind, buf)
        _UniffiConverterBytes.write(value.input, buf)
        _UniffiConverterSequenceTypeWorkflowActivationJob.write(value.jobs, buf)


class WorkflowEventRecord:
    """
    A workflow event record for FFI.
    """

    sequence: "int"
    """
    Event sequence number.
    """

    event_type: "str"
    """
    Event type as string.
    """

    payload: "bytes"
    """
    Event payload as JSON bytes.
    """

    def __init__(self, *, sequence: "int", event_type: "str", payload: "bytes"):
        self.sequence = sequence
        self.event_type = event_type
        self.payload = payload

    def __str__(self):
        return "WorkflowEventRecord(sequence={}, event_type={}, payload={})".format(self.sequence, self.event_type, self.payload)

    def __eq__(self, other):
        if self.sequence != other.sequence:
            return False
        if self.event_type != other.event_type:
            return False
        if self.payload != other.payload:
            return False
        return True

class _UniffiConverterTypeWorkflowEventRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WorkflowEventRecord(
            sequence=_UniffiConverterInt32.read(buf),
            event_type=_UniffiConverterString.read(buf),
            payload=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.sequence)
        _UniffiConverterString.check_lower(value.event_type)
        _UniffiConverterBytes.check_lower(value.payload)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.sequence, buf)
        _UniffiConverterString.write(value.event_type, buf)
        _UniffiConverterBytes.write(value.payload, buf)


class WorkflowMetadataFfi:
    """
    Workflow metadata passed from Kotlin/Swift to Rust FFI.
    Contains full metadata including optional schemas.
    """

    kind: "str"
    """
    Unique workflow kind identifier (required).
    """

    name: "str"
    """
    Human-readable name (defaults to kind if empty).
    """

    description: "typing.Optional[str]"
    """
    Optional description.
    """

    version: "typing.Optional[str]"
    """
    Version string (e.g., "1.0.0").
    """

    tags: "typing.List[str]"
    """
    Tags for categorization.
    """

    cancellable: "bool"
    """
    Whether the workflow can be cancelled.
    """

    timeout_seconds: "typing.Optional[int]"
    """
    Timeout in seconds.
    """

    input_schema: "typing.Optional[str]"
    """
    JSON Schema for input validation (JSON string).
    """

    output_schema: "typing.Optional[str]"
    """
    JSON Schema for output validation (JSON string).
    """

    def __init__(self, *, kind: "str", name: "str", description: "typing.Optional[str]", version: "typing.Optional[str]", tags: "typing.List[str]", cancellable: "bool", timeout_seconds: "typing.Optional[int]", input_schema: "typing.Optional[str]", output_schema: "typing.Optional[str]"):
        self.kind = kind
        self.name = name
        self.description = description
        self.version = version
        self.tags = tags
        self.cancellable = cancellable
        self.timeout_seconds = timeout_seconds
        self.input_schema = input_schema
        self.output_schema = output_schema

    def __str__(self):
        return "WorkflowMetadataFfi(kind={}, name={}, description={}, version={}, tags={}, cancellable={}, timeout_seconds={}, input_schema={}, output_schema={})".format(self.kind, self.name, self.description, self.version, self.tags, self.cancellable, self.timeout_seconds, self.input_schema, self.output_schema)

    def __eq__(self, other):
        if self.kind != other.kind:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.version != other.version:
            return False
        if self.tags != other.tags:
            return False
        if self.cancellable != other.cancellable:
            return False
        if self.timeout_seconds != other.timeout_seconds:
            return False
        if self.input_schema != other.input_schema:
            return False
        if self.output_schema != other.output_schema:
            return False
        return True

class _UniffiConverterTypeWorkflowMetadataFfi(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WorkflowMetadataFfi(
            kind=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            version=_UniffiConverterOptionalString.read(buf),
            tags=_UniffiConverterSequenceString.read(buf),
            cancellable=_UniffiConverterBool.read(buf),
            timeout_seconds=_UniffiConverterOptionalUInt32.read(buf),
            input_schema=_UniffiConverterOptionalString.read(buf),
            output_schema=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.kind)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.version)
        _UniffiConverterSequenceString.check_lower(value.tags)
        _UniffiConverterBool.check_lower(value.cancellable)
        _UniffiConverterOptionalUInt32.check_lower(value.timeout_seconds)
        _UniffiConverterOptionalString.check_lower(value.input_schema)
        _UniffiConverterOptionalString.check_lower(value.output_schema)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.kind, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.version, buf)
        _UniffiConverterSequenceString.write(value.tags, buf)
        _UniffiConverterBool.write(value.cancellable, buf)
        _UniffiConverterOptionalUInt32.write(value.timeout_seconds, buf)
        _UniffiConverterOptionalString.write(value.input_schema, buf)
        _UniffiConverterOptionalString.write(value.output_schema, buf)





class FfiChildWorkflowResult:
    """
    Result of scheduling a child workflow.
    """

    def __init__(self):
        raise RuntimeError("FfiChildWorkflowResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COMPLETED:
        """
        Child workflow completed during replay.
        """

        output: "bytes"
        """
        Serialized output as JSON bytes.
        """


        def __init__(self,output: "bytes"):
            self.output = output

        def __str__(self):
            return "FfiChildWorkflowResult.COMPLETED(output={})".format(self.output)

        def __eq__(self, other):
            if not other.is_completed():
                return False
            if self.output != other.output:
                return False
            return True
    
    class FAILED:
        """
        Child workflow failed during replay.
        """

        error: "str"
        """
        Error message.
        """


        def __init__(self,error: "str"):
            self.error = error

        def __str__(self):
            return "FfiChildWorkflowResult.FAILED(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_failed():
                return False
            if self.error != other.error:
                return False
            return True
    
    class PENDING:
        """
        Child workflow is pending - workflow should suspend.
        """

        child_execution_id: "str"
        """
        The child execution ID for tracking.
        """


        def __init__(self,child_execution_id: "str"):
            self.child_execution_id = child_execution_id

        def __str__(self):
            return "FfiChildWorkflowResult.PENDING(child_execution_id={})".format(self.child_execution_id)

        def __eq__(self, other):
            if not other.is_pending():
                return False
            if self.child_execution_id != other.child_execution_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_completed(self) -> bool:
        return isinstance(self, FfiChildWorkflowResult.COMPLETED)
    def is_failed(self) -> bool:
        return isinstance(self, FfiChildWorkflowResult.FAILED)
    def is_pending(self) -> bool:
        return isinstance(self, FfiChildWorkflowResult.PENDING)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiChildWorkflowResult.COMPLETED = type("FfiChildWorkflowResult.COMPLETED", (FfiChildWorkflowResult.COMPLETED, FfiChildWorkflowResult,), {})  # type: ignore
FfiChildWorkflowResult.FAILED = type("FfiChildWorkflowResult.FAILED", (FfiChildWorkflowResult.FAILED, FfiChildWorkflowResult,), {})  # type: ignore
FfiChildWorkflowResult.PENDING = type("FfiChildWorkflowResult.PENDING", (FfiChildWorkflowResult.PENDING, FfiChildWorkflowResult,), {})  # type: ignore




class _UniffiConverterTypeFfiChildWorkflowResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiChildWorkflowResult.COMPLETED(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiChildWorkflowResult.FAILED(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return FfiChildWorkflowResult.PENDING(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_completed():
            _UniffiConverterBytes.check_lower(value.output)
            return
        if value.is_failed():
            _UniffiConverterString.check_lower(value.error)
            return
        if value.is_pending():
            _UniffiConverterString.check_lower(value.child_execution_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_completed():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.output, buf)
        if value.is_failed():
            buf.write_i32(2)
            _UniffiConverterString.write(value.error, buf)
        if value.is_pending():
            buf.write_i32(3)
            _UniffiConverterString.write(value.child_execution_id, buf)




# FfiError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class FfiError(Exception):
    """
    FFI-compatible error type for all operations.

    This enum wraps internal errors into a format suitable for FFI,
    with simple field types that can cross the language boundary.

    Note: We use `msg` instead of `message` to avoid conflicts with
    Kotlin's Exception.message property in generated bindings.
    """

    pass

_UniffiTempFfiError = FfiError

class FfiError:  # type: ignore
    """
    FFI-compatible error type for all operations.

    This enum wraps internal errors into a format suitable for FFI,
    with simple field types that can cross the language boundary.

    Note: We use `msg` instead of `message` to avoid conflicts with
    Kotlin's Exception.message property in generated bindings.
    """

    class Grpc(_UniffiTempFfiError):
        """
        gRPC communication error.
        """

        def __init__(self, msg, code):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
                "code={!r}".format(code),
            ]))
            self.msg = msg
            self.code = code

        def __repr__(self):
            return "FfiError.Grpc({})".format(str(self))
    _UniffiTempFfiError.Grpc = Grpc # type: ignore
    class Timeout(_UniffiTempFfiError):
        """
        Operation timed out.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "FfiError.Timeout({})".format(str(self))
    _UniffiTempFfiError.Timeout = Timeout # type: ignore
    class Serialization(_UniffiTempFfiError):
        """
        Serialization or deserialization error.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "FfiError.Serialization({})".format(str(self))
    _UniffiTempFfiError.Serialization = Serialization # type: ignore
    class DeterminismViolation(_UniffiTempFfiError):
        """
        Determinism violation detected during replay.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "FfiError.DeterminismViolation({})".format(str(self))
    _UniffiTempFfiError.DeterminismViolation = DeterminismViolation # type: ignore
    class InvalidConfiguration(_UniffiTempFfiError):
        """
        Invalid configuration provided.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "FfiError.InvalidConfiguration({})".format(str(self))
    _UniffiTempFfiError.InvalidConfiguration = InvalidConfiguration # type: ignore
    class Cancelled(_UniffiTempFfiError):
        """
        Operation was cancelled.
        """

        def __init__(self):
            pass

        def __repr__(self):
            return "FfiError.Cancelled({})".format(str(self))
    _UniffiTempFfiError.Cancelled = Cancelled # type: ignore
    class ShuttingDown(_UniffiTempFfiError):
        """
        Worker is shutting down.
        """

        def __init__(self):
            pass

        def __repr__(self):
            return "FfiError.ShuttingDown({})".format(str(self))
    _UniffiTempFfiError.ShuttingDown = ShuttingDown # type: ignore
    class InvalidState(_UniffiTempFfiError):
        """
        Invalid state for the requested operation.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "FfiError.InvalidState({})".format(str(self))
    _UniffiTempFfiError.InvalidState = InvalidState # type: ignore
    class NoWorkAvailable(_UniffiTempFfiError):
        """
        No work available (poll returned empty).
        """

        def __init__(self):
            pass

        def __repr__(self):
            return "FfiError.NoWorkAvailable({})".format(str(self))
    _UniffiTempFfiError.NoWorkAvailable = NoWorkAvailable # type: ignore
    class Other(_UniffiTempFfiError):
        """
        Generic error for other cases.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "FfiError.Other({})".format(str(self))
    _UniffiTempFfiError.Other = Other # type: ignore

FfiError = _UniffiTempFfiError # type: ignore
del _UniffiTempFfiError


class _UniffiConverterTypeFfiError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiError.Grpc(
                _UniffiConverterString.read(buf),
                _UniffiConverterInt32.read(buf),
            )
        if variant == 2:
            return FfiError.Timeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return FfiError.Serialization(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return FfiError.DeterminismViolation(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return FfiError.InvalidConfiguration(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return FfiError.Cancelled(
            )
        if variant == 7:
            return FfiError.ShuttingDown(
            )
        if variant == 8:
            return FfiError.InvalidState(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return FfiError.NoWorkAvailable(
            )
        if variant == 10:
            return FfiError.Other(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, FfiError.Grpc):
            _UniffiConverterString.check_lower(value.msg)
            _UniffiConverterInt32.check_lower(value.code)
            return
        if isinstance(value, FfiError.Timeout):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, FfiError.Serialization):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, FfiError.DeterminismViolation):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, FfiError.InvalidConfiguration):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, FfiError.Cancelled):
            return
        if isinstance(value, FfiError.ShuttingDown):
            return
        if isinstance(value, FfiError.InvalidState):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, FfiError.NoWorkAvailable):
            return
        if isinstance(value, FfiError.Other):
            _UniffiConverterString.check_lower(value.msg)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, FfiError.Grpc):
            buf.write_i32(1)
            _UniffiConverterString.write(value.msg, buf)
            _UniffiConverterInt32.write(value.code, buf)
        if isinstance(value, FfiError.Timeout):
            buf.write_i32(2)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, FfiError.Serialization):
            buf.write_i32(3)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, FfiError.DeterminismViolation):
            buf.write_i32(4)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, FfiError.InvalidConfiguration):
            buf.write_i32(5)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, FfiError.Cancelled):
            buf.write_i32(6)
        if isinstance(value, FfiError.ShuttingDown):
            buf.write_i32(7)
        if isinstance(value, FfiError.InvalidState):
            buf.write_i32(8)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, FfiError.NoWorkAvailable):
            buf.write_i32(9)
        if isinstance(value, FfiError.Other):
            buf.write_i32(10)
            _UniffiConverterString.write(value.msg, buf)





class FfiEventType(enum.Enum):
    """
    Event types that can occur during workflow execution.

    This enum mirrors `flovyn_worker_core::EventType` but with uniffi support.
    """

    WORKFLOW_STARTED = 0
    
    WORKFLOW_COMPLETED = 1
    
    WORKFLOW_EXECUTION_FAILED = 2
    
    WORKFLOW_SUSPENDED = 3
    
    CANCELLATION_REQUESTED = 4
    
    OPERATION_COMPLETED = 5
    
    STATE_SET = 6
    
    STATE_CLEARED = 7
    
    TASK_SCHEDULED = 8
    
    TASK_COMPLETED = 9
    
    TASK_FAILED = 10
    
    TASK_CANCELLED = 11
    
    PROMISE_CREATED = 12
    
    PROMISE_RESOLVED = 13
    
    PROMISE_REJECTED = 14
    
    PROMISE_TIMEOUT = 15
    
    CHILD_WORKFLOW_INITIATED = 16
    
    CHILD_WORKFLOW_STARTED = 17
    
    CHILD_WORKFLOW_COMPLETED = 18
    
    CHILD_WORKFLOW_FAILED = 19
    
    CHILD_WORKFLOW_CANCELLED = 20
    
    TIMER_STARTED = 21
    
    TIMER_FIRED = 22
    
    TIMER_CANCELLED = 23
    
    SIGNAL_RECEIVED = 24
    


class _UniffiConverterTypeFfiEventType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiEventType.WORKFLOW_STARTED
        if variant == 2:
            return FfiEventType.WORKFLOW_COMPLETED
        if variant == 3:
            return FfiEventType.WORKFLOW_EXECUTION_FAILED
        if variant == 4:
            return FfiEventType.WORKFLOW_SUSPENDED
        if variant == 5:
            return FfiEventType.CANCELLATION_REQUESTED
        if variant == 6:
            return FfiEventType.OPERATION_COMPLETED
        if variant == 7:
            return FfiEventType.STATE_SET
        if variant == 8:
            return FfiEventType.STATE_CLEARED
        if variant == 9:
            return FfiEventType.TASK_SCHEDULED
        if variant == 10:
            return FfiEventType.TASK_COMPLETED
        if variant == 11:
            return FfiEventType.TASK_FAILED
        if variant == 12:
            return FfiEventType.TASK_CANCELLED
        if variant == 13:
            return FfiEventType.PROMISE_CREATED
        if variant == 14:
            return FfiEventType.PROMISE_RESOLVED
        if variant == 15:
            return FfiEventType.PROMISE_REJECTED
        if variant == 16:
            return FfiEventType.PROMISE_TIMEOUT
        if variant == 17:
            return FfiEventType.CHILD_WORKFLOW_INITIATED
        if variant == 18:
            return FfiEventType.CHILD_WORKFLOW_STARTED
        if variant == 19:
            return FfiEventType.CHILD_WORKFLOW_COMPLETED
        if variant == 20:
            return FfiEventType.CHILD_WORKFLOW_FAILED
        if variant == 21:
            return FfiEventType.CHILD_WORKFLOW_CANCELLED
        if variant == 22:
            return FfiEventType.TIMER_STARTED
        if variant == 23:
            return FfiEventType.TIMER_FIRED
        if variant == 24:
            return FfiEventType.TIMER_CANCELLED
        if variant == 25:
            return FfiEventType.SIGNAL_RECEIVED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiEventType.WORKFLOW_STARTED:
            return
        if value == FfiEventType.WORKFLOW_COMPLETED:
            return
        if value == FfiEventType.WORKFLOW_EXECUTION_FAILED:
            return
        if value == FfiEventType.WORKFLOW_SUSPENDED:
            return
        if value == FfiEventType.CANCELLATION_REQUESTED:
            return
        if value == FfiEventType.OPERATION_COMPLETED:
            return
        if value == FfiEventType.STATE_SET:
            return
        if value == FfiEventType.STATE_CLEARED:
            return
        if value == FfiEventType.TASK_SCHEDULED:
            return
        if value == FfiEventType.TASK_COMPLETED:
            return
        if value == FfiEventType.TASK_FAILED:
            return
        if value == FfiEventType.TASK_CANCELLED:
            return
        if value == FfiEventType.PROMISE_CREATED:
            return
        if value == FfiEventType.PROMISE_RESOLVED:
            return
        if value == FfiEventType.PROMISE_REJECTED:
            return
        if value == FfiEventType.PROMISE_TIMEOUT:
            return
        if value == FfiEventType.CHILD_WORKFLOW_INITIATED:
            return
        if value == FfiEventType.CHILD_WORKFLOW_STARTED:
            return
        if value == FfiEventType.CHILD_WORKFLOW_COMPLETED:
            return
        if value == FfiEventType.CHILD_WORKFLOW_FAILED:
            return
        if value == FfiEventType.CHILD_WORKFLOW_CANCELLED:
            return
        if value == FfiEventType.TIMER_STARTED:
            return
        if value == FfiEventType.TIMER_FIRED:
            return
        if value == FfiEventType.TIMER_CANCELLED:
            return
        if value == FfiEventType.SIGNAL_RECEIVED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiEventType.WORKFLOW_STARTED:
            buf.write_i32(1)
        if value == FfiEventType.WORKFLOW_COMPLETED:
            buf.write_i32(2)
        if value == FfiEventType.WORKFLOW_EXECUTION_FAILED:
            buf.write_i32(3)
        if value == FfiEventType.WORKFLOW_SUSPENDED:
            buf.write_i32(4)
        if value == FfiEventType.CANCELLATION_REQUESTED:
            buf.write_i32(5)
        if value == FfiEventType.OPERATION_COMPLETED:
            buf.write_i32(6)
        if value == FfiEventType.STATE_SET:
            buf.write_i32(7)
        if value == FfiEventType.STATE_CLEARED:
            buf.write_i32(8)
        if value == FfiEventType.TASK_SCHEDULED:
            buf.write_i32(9)
        if value == FfiEventType.TASK_COMPLETED:
            buf.write_i32(10)
        if value == FfiEventType.TASK_FAILED:
            buf.write_i32(11)
        if value == FfiEventType.TASK_CANCELLED:
            buf.write_i32(12)
        if value == FfiEventType.PROMISE_CREATED:
            buf.write_i32(13)
        if value == FfiEventType.PROMISE_RESOLVED:
            buf.write_i32(14)
        if value == FfiEventType.PROMISE_REJECTED:
            buf.write_i32(15)
        if value == FfiEventType.PROMISE_TIMEOUT:
            buf.write_i32(16)
        if value == FfiEventType.CHILD_WORKFLOW_INITIATED:
            buf.write_i32(17)
        if value == FfiEventType.CHILD_WORKFLOW_STARTED:
            buf.write_i32(18)
        if value == FfiEventType.CHILD_WORKFLOW_COMPLETED:
            buf.write_i32(19)
        if value == FfiEventType.CHILD_WORKFLOW_FAILED:
            buf.write_i32(20)
        if value == FfiEventType.CHILD_WORKFLOW_CANCELLED:
            buf.write_i32(21)
        if value == FfiEventType.TIMER_STARTED:
            buf.write_i32(22)
        if value == FfiEventType.TIMER_FIRED:
            buf.write_i32(23)
        if value == FfiEventType.TIMER_CANCELLED:
            buf.write_i32(24)
        if value == FfiEventType.SIGNAL_RECEIVED:
            buf.write_i32(25)







class FfiOperationResult:
    """
    Result of running a side effect operation.
    """

    def __init__(self):
        raise RuntimeError("FfiOperationResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CACHED:
        """
        Operation completed during replay - return cached value.
        """

        value: "bytes"
        """
        Serialized value as JSON bytes.
        """


        def __init__(self,value: "bytes"):
            self.value = value

        def __str__(self):
            return "FfiOperationResult.CACHED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_cached():
                return False
            if self.value != other.value:
                return False
            return True
    
    class EXECUTE:
        """
        Operation is new - SDK should execute and record.
        """

        operation_seq: "int"
        """
        Sequence number for this operation.
        """


        def __init__(self,operation_seq: "int"):
            self.operation_seq = operation_seq

        def __str__(self):
            return "FfiOperationResult.EXECUTE(operation_seq={})".format(self.operation_seq)

        def __eq__(self, other):
            if not other.is_execute():
                return False
            if self.operation_seq != other.operation_seq:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_cached(self) -> bool:
        return isinstance(self, FfiOperationResult.CACHED)
    def is_execute(self) -> bool:
        return isinstance(self, FfiOperationResult.EXECUTE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiOperationResult.CACHED = type("FfiOperationResult.CACHED", (FfiOperationResult.CACHED, FfiOperationResult,), {})  # type: ignore
FfiOperationResult.EXECUTE = type("FfiOperationResult.EXECUTE", (FfiOperationResult.EXECUTE, FfiOperationResult,), {})  # type: ignore




class _UniffiConverterTypeFfiOperationResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiOperationResult.CACHED(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiOperationResult.EXECUTE(
                _UniffiConverterUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_cached():
            _UniffiConverterBytes.check_lower(value.value)
            return
        if value.is_execute():
            _UniffiConverterUInt32.check_lower(value.operation_seq)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_cached():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_execute():
            buf.write_i32(2)
            _UniffiConverterUInt32.write(value.operation_seq, buf)







class FfiPromiseResult:
    """
    Result of creating a promise.
    """

    def __init__(self):
        raise RuntimeError("FfiPromiseResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class RESOLVED:
        """
        Promise resolved during replay.
        """

        value: "bytes"
        """
        Serialized value as JSON bytes.
        """


        def __init__(self,value: "bytes"):
            self.value = value

        def __str__(self):
            return "FfiPromiseResult.RESOLVED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_resolved():
                return False
            if self.value != other.value:
                return False
            return True
    
    class REJECTED:
        """
        Promise rejected during replay.
        """

        error: "str"
        """
        Error message.
        """


        def __init__(self,error: "str"):
            self.error = error

        def __str__(self):
            return "FfiPromiseResult.REJECTED(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_rejected():
                return False
            if self.error != other.error:
                return False
            return True
    
    class TIMED_OUT:
        """
        Promise timed out during replay.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiPromiseResult.TIMED_OUT()".format()

        def __eq__(self, other):
            if not other.is_timed_out():
                return False
            return True
    
    class PENDING:
        """
        Promise is pending - workflow should suspend.
        """

        promise_id: "str"
        """
        The promise ID for tracking.
        """


        def __init__(self,promise_id: "str"):
            self.promise_id = promise_id

        def __str__(self):
            return "FfiPromiseResult.PENDING(promise_id={})".format(self.promise_id)

        def __eq__(self, other):
            if not other.is_pending():
                return False
            if self.promise_id != other.promise_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_resolved(self) -> bool:
        return isinstance(self, FfiPromiseResult.RESOLVED)
    def is_rejected(self) -> bool:
        return isinstance(self, FfiPromiseResult.REJECTED)
    def is_timed_out(self) -> bool:
        return isinstance(self, FfiPromiseResult.TIMED_OUT)
    def is_pending(self) -> bool:
        return isinstance(self, FfiPromiseResult.PENDING)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiPromiseResult.RESOLVED = type("FfiPromiseResult.RESOLVED", (FfiPromiseResult.RESOLVED, FfiPromiseResult,), {})  # type: ignore
FfiPromiseResult.REJECTED = type("FfiPromiseResult.REJECTED", (FfiPromiseResult.REJECTED, FfiPromiseResult,), {})  # type: ignore
FfiPromiseResult.TIMED_OUT = type("FfiPromiseResult.TIMED_OUT", (FfiPromiseResult.TIMED_OUT, FfiPromiseResult,), {})  # type: ignore
FfiPromiseResult.PENDING = type("FfiPromiseResult.PENDING", (FfiPromiseResult.PENDING, FfiPromiseResult,), {})  # type: ignore




class _UniffiConverterTypeFfiPromiseResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiPromiseResult.RESOLVED(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiPromiseResult.REJECTED(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return FfiPromiseResult.TIMED_OUT(
            )
        if variant == 4:
            return FfiPromiseResult.PENDING(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_resolved():
            _UniffiConverterBytes.check_lower(value.value)
            return
        if value.is_rejected():
            _UniffiConverterString.check_lower(value.error)
            return
        if value.is_timed_out():
            return
        if value.is_pending():
            _UniffiConverterString.check_lower(value.promise_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_resolved():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_rejected():
            buf.write_i32(2)
            _UniffiConverterString.write(value.error, buf)
        if value.is_timed_out():
            buf.write_i32(3)
        if value.is_pending():
            buf.write_i32(4)
            _UniffiConverterString.write(value.promise_id, buf)







class FfiSignalResult:
    """
    Result of waiting for a signal.
    """

    def __init__(self):
        raise RuntimeError("FfiSignalResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class RECEIVED:
        """
        Signal received - return the signal data.
        """

        signal_name: "str"
        """
        Signal name.
        """

        value: "bytes"
        """
        Serialized value as JSON bytes.
        """


        def __init__(self,signal_name: "str", value: "bytes"):
            self.signal_name = signal_name
            self.value = value

        def __str__(self):
            return "FfiSignalResult.RECEIVED(signal_name={}, value={})".format(self.signal_name, self.value)

        def __eq__(self, other):
            if not other.is_received():
                return False
            if self.signal_name != other.signal_name:
                return False
            if self.value != other.value:
                return False
            return True
    
    class PENDING:
        """
        No signal available - workflow should suspend.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiSignalResult.PENDING()".format()

        def __eq__(self, other):
            if not other.is_pending():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_received(self) -> bool:
        return isinstance(self, FfiSignalResult.RECEIVED)
    def is_pending(self) -> bool:
        return isinstance(self, FfiSignalResult.PENDING)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiSignalResult.RECEIVED = type("FfiSignalResult.RECEIVED", (FfiSignalResult.RECEIVED, FfiSignalResult,), {})  # type: ignore
FfiSignalResult.PENDING = type("FfiSignalResult.PENDING", (FfiSignalResult.PENDING, FfiSignalResult,), {})  # type: ignore




class _UniffiConverterTypeFfiSignalResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiSignalResult.RECEIVED(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiSignalResult.PENDING(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_received():
            _UniffiConverterString.check_lower(value.signal_name)
            _UniffiConverterBytes.check_lower(value.value)
            return
        if value.is_pending():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_received():
            buf.write_i32(1)
            _UniffiConverterString.write(value.signal_name, buf)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_pending():
            buf.write_i32(2)







class FfiStopReason:
    """
    Reason for worker stopping.
    """

    def __init__(self):
        raise RuntimeError("FfiStopReason cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GRACEFUL:
        """
        Normal graceful shutdown.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiStopReason.GRACEFUL()".format()

        def __eq__(self, other):
            if not other.is_graceful():
                return False
            return True
    
    class IMMEDIATE:
        """
        Immediate stop requested.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiStopReason.IMMEDIATE()".format()

        def __eq__(self, other):
            if not other.is_immediate():
                return False
            return True
    
    class ABORTED:
        """
        Aborted.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiStopReason.ABORTED()".format()

        def __eq__(self, other):
            if not other.is_aborted():
                return False
            return True
    
    class ERROR:
        """
        Unrecoverable error.
        """

        msg: "str"

        def __init__(self,msg: "str"):
            self.msg = msg

        def __str__(self):
            return "FfiStopReason.ERROR(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_error():
                return False
            if self.msg != other.msg:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_graceful(self) -> bool:
        return isinstance(self, FfiStopReason.GRACEFUL)
    def is_immediate(self) -> bool:
        return isinstance(self, FfiStopReason.IMMEDIATE)
    def is_aborted(self) -> bool:
        return isinstance(self, FfiStopReason.ABORTED)
    def is_error(self) -> bool:
        return isinstance(self, FfiStopReason.ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiStopReason.GRACEFUL = type("FfiStopReason.GRACEFUL", (FfiStopReason.GRACEFUL, FfiStopReason,), {})  # type: ignore
FfiStopReason.IMMEDIATE = type("FfiStopReason.IMMEDIATE", (FfiStopReason.IMMEDIATE, FfiStopReason,), {})  # type: ignore
FfiStopReason.ABORTED = type("FfiStopReason.ABORTED", (FfiStopReason.ABORTED, FfiStopReason,), {})  # type: ignore
FfiStopReason.ERROR = type("FfiStopReason.ERROR", (FfiStopReason.ERROR, FfiStopReason,), {})  # type: ignore




class _UniffiConverterTypeFfiStopReason(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiStopReason.GRACEFUL(
            )
        if variant == 2:
            return FfiStopReason.IMMEDIATE(
            )
        if variant == 3:
            return FfiStopReason.ABORTED(
            )
        if variant == 4:
            return FfiStopReason.ERROR(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_graceful():
            return
        if value.is_immediate():
            return
        if value.is_aborted():
            return
        if value.is_error():
            _UniffiConverterString.check_lower(value.msg)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_graceful():
            buf.write_i32(1)
        if value.is_immediate():
            buf.write_i32(2)
        if value.is_aborted():
            buf.write_i32(3)
        if value.is_error():
            buf.write_i32(4)
            _UniffiConverterString.write(value.msg, buf)







class FfiStreamEvent:
    """
    Stream event types for FFI.
    """

    def __init__(self):
        raise RuntimeError("FfiStreamEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TOKEN:
        """
        LLM token or text chunk.
        """

        text: "str"
        """
        The token or text chunk.
        """


        def __init__(self,text: "str"):
            self.text = text

        def __str__(self):
            return "FfiStreamEvent.TOKEN(text={})".format(self.text)

        def __eq__(self, other):
            if not other.is_token():
                return False
            if self.text != other.text:
                return False
            return True
    
    class PROGRESS:
        """
        Progress update with optional details.
        """

        progress: "float"
        """
        Progress value (0.0 to 1.0).
        """

        details: "typing.Optional[str]"
        """
        Optional progress details.
        """


        def __init__(self,progress: "float", details: "typing.Optional[str]"):
            self.progress = progress
            self.details = details

        def __str__(self):
            return "FfiStreamEvent.PROGRESS(progress={}, details={})".format(self.progress, self.details)

        def __eq__(self, other):
            if not other.is_progress():
                return False
            if self.progress != other.progress:
                return False
            if self.details != other.details:
                return False
            return True
    
    class DATA:
        """
        Arbitrary structured data.
        """

        data: "bytes"
        """
        Data payload as JSON bytes.
        """


        def __init__(self,data: "bytes"):
            self.data = data

        def __str__(self):
            return "FfiStreamEvent.DATA(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_data():
                return False
            if self.data != other.data:
                return False
            return True
    
    class ERROR:
        """
        Error notification.
        """

        message: "str"
        """
        Error message.
        """

        code: "typing.Optional[str]"
        """
        Optional error code.
        """


        def __init__(self,message: "str", code: "typing.Optional[str]"):
            self.message = message
            self.code = code

        def __str__(self):
            return "FfiStreamEvent.ERROR(message={}, code={})".format(self.message, self.code)

        def __eq__(self, other):
            if not other.is_error():
                return False
            if self.message != other.message:
                return False
            if self.code != other.code:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_token(self) -> bool:
        return isinstance(self, FfiStreamEvent.TOKEN)
    def is_progress(self) -> bool:
        return isinstance(self, FfiStreamEvent.PROGRESS)
    def is_data(self) -> bool:
        return isinstance(self, FfiStreamEvent.DATA)
    def is_error(self) -> bool:
        return isinstance(self, FfiStreamEvent.ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiStreamEvent.TOKEN = type("FfiStreamEvent.TOKEN", (FfiStreamEvent.TOKEN, FfiStreamEvent,), {})  # type: ignore
FfiStreamEvent.PROGRESS = type("FfiStreamEvent.PROGRESS", (FfiStreamEvent.PROGRESS, FfiStreamEvent,), {})  # type: ignore
FfiStreamEvent.DATA = type("FfiStreamEvent.DATA", (FfiStreamEvent.DATA, FfiStreamEvent,), {})  # type: ignore
FfiStreamEvent.ERROR = type("FfiStreamEvent.ERROR", (FfiStreamEvent.ERROR, FfiStreamEvent,), {})  # type: ignore




class _UniffiConverterTypeFfiStreamEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiStreamEvent.TOKEN(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return FfiStreamEvent.PROGRESS(
                _UniffiConverterDouble.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 3:
            return FfiStreamEvent.DATA(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 4:
            return FfiStreamEvent.ERROR(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_token():
            _UniffiConverterString.check_lower(value.text)
            return
        if value.is_progress():
            _UniffiConverterDouble.check_lower(value.progress)
            _UniffiConverterOptionalString.check_lower(value.details)
            return
        if value.is_data():
            _UniffiConverterBytes.check_lower(value.data)
            return
        if value.is_error():
            _UniffiConverterString.check_lower(value.message)
            _UniffiConverterOptionalString.check_lower(value.code)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_token():
            buf.write_i32(1)
            _UniffiConverterString.write(value.text, buf)
        if value.is_progress():
            buf.write_i32(2)
            _UniffiConverterDouble.write(value.progress, buf)
            _UniffiConverterOptionalString.write(value.details, buf)
        if value.is_data():
            buf.write_i32(3)
            _UniffiConverterBytes.write(value.data, buf)
        if value.is_error():
            buf.write_i32(4)
            _UniffiConverterString.write(value.message, buf)
            _UniffiConverterOptionalString.write(value.code, buf)







class FfiTaskExecutionResult:
    """
    Task execution result for FFI.
    """

    def __init__(self):
        raise RuntimeError("FfiTaskExecutionResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COMPLETED:
        """
        Task completed successfully.
        """

        output: "bytes"
        """
        Serialized output as JSON bytes.
        """


        def __init__(self,output: "bytes"):
            self.output = output

        def __str__(self):
            return "FfiTaskExecutionResult.COMPLETED(output={})".format(self.output)

        def __eq__(self, other):
            if not other.is_completed():
                return False
            if self.output != other.output:
                return False
            return True
    
    class FAILED:
        """
        Task failed with an error.
        """

        error: "str"
        """
        Error message.
        """

        retryable: "bool"
        """
        Whether this is a retryable error.
        """


        def __init__(self,error: "str", retryable: "bool"):
            self.error = error
            self.retryable = retryable

        def __str__(self):
            return "FfiTaskExecutionResult.FAILED(error={}, retryable={})".format(self.error, self.retryable)

        def __eq__(self, other):
            if not other.is_failed():
                return False
            if self.error != other.error:
                return False
            if self.retryable != other.retryable:
                return False
            return True
    
    class CANCELLED:
        """
        Task was cancelled.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiTaskExecutionResult.CANCELLED()".format()

        def __eq__(self, other):
            if not other.is_cancelled():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_completed(self) -> bool:
        return isinstance(self, FfiTaskExecutionResult.COMPLETED)
    def is_failed(self) -> bool:
        return isinstance(self, FfiTaskExecutionResult.FAILED)
    def is_cancelled(self) -> bool:
        return isinstance(self, FfiTaskExecutionResult.CANCELLED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiTaskExecutionResult.COMPLETED = type("FfiTaskExecutionResult.COMPLETED", (FfiTaskExecutionResult.COMPLETED, FfiTaskExecutionResult,), {})  # type: ignore
FfiTaskExecutionResult.FAILED = type("FfiTaskExecutionResult.FAILED", (FfiTaskExecutionResult.FAILED, FfiTaskExecutionResult,), {})  # type: ignore
FfiTaskExecutionResult.CANCELLED = type("FfiTaskExecutionResult.CANCELLED", (FfiTaskExecutionResult.CANCELLED, FfiTaskExecutionResult,), {})  # type: ignore




class _UniffiConverterTypeFfiTaskExecutionResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiTaskExecutionResult.COMPLETED(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiTaskExecutionResult.FAILED(
                _UniffiConverterString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return FfiTaskExecutionResult.CANCELLED(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_completed():
            _UniffiConverterBytes.check_lower(value.output)
            return
        if value.is_failed():
            _UniffiConverterString.check_lower(value.error)
            _UniffiConverterBool.check_lower(value.retryable)
            return
        if value.is_cancelled():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_completed():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.output, buf)
        if value.is_failed():
            buf.write_i32(2)
            _UniffiConverterString.write(value.error, buf)
            _UniffiConverterBool.write(value.retryable, buf)
        if value.is_cancelled():
            buf.write_i32(3)







class FfiTaskResult:
    """
    Result of scheduling a task.
    """

    def __init__(self):
        raise RuntimeError("FfiTaskResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COMPLETED:
        """
        Task completed during replay - return cached result.
        """

        output: "bytes"
        """
        Serialized output as JSON bytes.
        """


        def __init__(self,output: "bytes"):
            self.output = output

        def __str__(self):
            return "FfiTaskResult.COMPLETED(output={})".format(self.output)

        def __eq__(self, other):
            if not other.is_completed():
                return False
            if self.output != other.output:
                return False
            return True
    
    class FAILED:
        """
        Task failed during replay - return cached error.
        """

        error: "str"
        """
        Error message.
        """

        retryable: "bool"
        """
        Whether this is retryable.
        """


        def __init__(self,error: "str", retryable: "bool"):
            self.error = error
            self.retryable = retryable

        def __str__(self):
            return "FfiTaskResult.FAILED(error={}, retryable={})".format(self.error, self.retryable)

        def __eq__(self, other):
            if not other.is_failed():
                return False
            if self.error != other.error:
                return False
            if self.retryable != other.retryable:
                return False
            return True
    
    class PENDING:
        """
        Task is pending - workflow should suspend.
        """

        task_execution_id: "str"
        """
        The task execution ID for tracking.
        """


        def __init__(self,task_execution_id: "str"):
            self.task_execution_id = task_execution_id

        def __str__(self):
            return "FfiTaskResult.PENDING(task_execution_id={})".format(self.task_execution_id)

        def __eq__(self, other):
            if not other.is_pending():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_completed(self) -> bool:
        return isinstance(self, FfiTaskResult.COMPLETED)
    def is_failed(self) -> bool:
        return isinstance(self, FfiTaskResult.FAILED)
    def is_pending(self) -> bool:
        return isinstance(self, FfiTaskResult.PENDING)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiTaskResult.COMPLETED = type("FfiTaskResult.COMPLETED", (FfiTaskResult.COMPLETED, FfiTaskResult,), {})  # type: ignore
FfiTaskResult.FAILED = type("FfiTaskResult.FAILED", (FfiTaskResult.FAILED, FfiTaskResult,), {})  # type: ignore
FfiTaskResult.PENDING = type("FfiTaskResult.PENDING", (FfiTaskResult.PENDING, FfiTaskResult,), {})  # type: ignore




class _UniffiConverterTypeFfiTaskResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiTaskResult.COMPLETED(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiTaskResult.FAILED(
                _UniffiConverterString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return FfiTaskResult.PENDING(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_completed():
            _UniffiConverterBytes.check_lower(value.output)
            return
        if value.is_failed():
            _UniffiConverterString.check_lower(value.error)
            _UniffiConverterBool.check_lower(value.retryable)
            return
        if value.is_pending():
            _UniffiConverterString.check_lower(value.task_execution_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_completed():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.output, buf)
        if value.is_failed():
            buf.write_i32(2)
            _UniffiConverterString.write(value.error, buf)
            _UniffiConverterBool.write(value.retryable, buf)
        if value.is_pending():
            buf.write_i32(3)
            _UniffiConverterString.write(value.task_execution_id, buf)







class FfiTimerResult:
    """
    Result of starting a timer.
    """

    def __init__(self):
        raise RuntimeError("FfiTimerResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FIRED:
        """
        Timer fired during replay.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiTimerResult.FIRED()".format()

        def __eq__(self, other):
            if not other.is_fired():
                return False
            return True
    
    class PENDING:
        """
        Timer is pending - workflow should suspend.
        """

        timer_id: "str"
        """
        The timer ID for tracking.
        """


        def __init__(self,timer_id: "str"):
            self.timer_id = timer_id

        def __str__(self):
            return "FfiTimerResult.PENDING(timer_id={})".format(self.timer_id)

        def __eq__(self, other):
            if not other.is_pending():
                return False
            if self.timer_id != other.timer_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fired(self) -> bool:
        return isinstance(self, FfiTimerResult.FIRED)
    def is_pending(self) -> bool:
        return isinstance(self, FfiTimerResult.PENDING)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiTimerResult.FIRED = type("FfiTimerResult.FIRED", (FfiTimerResult.FIRED, FfiTimerResult,), {})  # type: ignore
FfiTimerResult.PENDING = type("FfiTimerResult.PENDING", (FfiTimerResult.PENDING, FfiTimerResult,), {})  # type: ignore




class _UniffiConverterTypeFfiTimerResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiTimerResult.FIRED(
            )
        if variant == 2:
            return FfiTimerResult.PENDING(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_fired():
            return
        if value.is_pending():
            _UniffiConverterString.check_lower(value.timer_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_fired():
            buf.write_i32(1)
        if value.is_pending():
            buf.write_i32(2)
            _UniffiConverterString.write(value.timer_id, buf)







class FfiWorkerStatus:
    """
    Worker status enum for FFI.
    """

    def __init__(self):
        raise RuntimeError("FfiWorkerStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INITIALIZING:
        """
        Worker is initializing.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiWorkerStatus.INITIALIZING()".format()

        def __eq__(self, other):
            if not other.is_initializing():
                return False
            return True
    
    class REGISTERING:
        """
        Worker is registering with the server.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "FfiWorkerStatus.REGISTERING()".format()

        def __eq__(self, other):
            if not other.is_registering():
                return False
            return True
    
    class RUNNING:
        """
        Worker is active and polling.
        """

        server_worker_id: "typing.Optional[str]"
        started_at_ms: "int"

        def __init__(self,server_worker_id: "typing.Optional[str]", started_at_ms: "int"):
            self.server_worker_id = server_worker_id
            self.started_at_ms = started_at_ms

        def __str__(self):
            return "FfiWorkerStatus.RUNNING(server_worker_id={}, started_at_ms={})".format(self.server_worker_id, self.started_at_ms)

        def __eq__(self, other):
            if not other.is_running():
                return False
            if self.server_worker_id != other.server_worker_id:
                return False
            if self.started_at_ms != other.started_at_ms:
                return False
            return True
    
    class PAUSED:
        """
        Worker is paused.
        """

        reason: "str"

        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "FfiWorkerStatus.PAUSED(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_paused():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class RECONNECTING:
        """
        Worker is reconnecting.
        """

        attempts: "int"
        disconnected_at_ms: "int"
        last_error: "typing.Optional[str]"

        def __init__(self,attempts: "int", disconnected_at_ms: "int", last_error: "typing.Optional[str]"):
            self.attempts = attempts
            self.disconnected_at_ms = disconnected_at_ms
            self.last_error = last_error

        def __str__(self):
            return "FfiWorkerStatus.RECONNECTING(attempts={}, disconnected_at_ms={}, last_error={})".format(self.attempts, self.disconnected_at_ms, self.last_error)

        def __eq__(self, other):
            if not other.is_reconnecting():
                return False
            if self.attempts != other.attempts:
                return False
            if self.disconnected_at_ms != other.disconnected_at_ms:
                return False
            if self.last_error != other.last_error:
                return False
            return True
    
    class SHUTTING_DOWN:
        """
        Worker is shutting down.
        """

        requested_at_ms: "int"
        in_flight_count: "int"

        def __init__(self,requested_at_ms: "int", in_flight_count: "int"):
            self.requested_at_ms = requested_at_ms
            self.in_flight_count = in_flight_count

        def __str__(self):
            return "FfiWorkerStatus.SHUTTING_DOWN(requested_at_ms={}, in_flight_count={})".format(self.requested_at_ms, self.in_flight_count)

        def __eq__(self, other):
            if not other.is_shutting_down():
                return False
            if self.requested_at_ms != other.requested_at_ms:
                return False
            if self.in_flight_count != other.in_flight_count:
                return False
            return True
    
    class STOPPED:
        """
        Worker has stopped.
        """

        stopped_at_ms: "int"
        reason: "FfiStopReason"

        def __init__(self,stopped_at_ms: "int", reason: "FfiStopReason"):
            self.stopped_at_ms = stopped_at_ms
            self.reason = reason

        def __str__(self):
            return "FfiWorkerStatus.STOPPED(stopped_at_ms={}, reason={})".format(self.stopped_at_ms, self.reason)

        def __eq__(self, other):
            if not other.is_stopped():
                return False
            if self.stopped_at_ms != other.stopped_at_ms:
                return False
            if self.reason != other.reason:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_initializing(self) -> bool:
        return isinstance(self, FfiWorkerStatus.INITIALIZING)
    def is_registering(self) -> bool:
        return isinstance(self, FfiWorkerStatus.REGISTERING)
    def is_running(self) -> bool:
        return isinstance(self, FfiWorkerStatus.RUNNING)
    def is_paused(self) -> bool:
        return isinstance(self, FfiWorkerStatus.PAUSED)
    def is_reconnecting(self) -> bool:
        return isinstance(self, FfiWorkerStatus.RECONNECTING)
    def is_shutting_down(self) -> bool:
        return isinstance(self, FfiWorkerStatus.SHUTTING_DOWN)
    def is_stopped(self) -> bool:
        return isinstance(self, FfiWorkerStatus.STOPPED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiWorkerStatus.INITIALIZING = type("FfiWorkerStatus.INITIALIZING", (FfiWorkerStatus.INITIALIZING, FfiWorkerStatus,), {})  # type: ignore
FfiWorkerStatus.REGISTERING = type("FfiWorkerStatus.REGISTERING", (FfiWorkerStatus.REGISTERING, FfiWorkerStatus,), {})  # type: ignore
FfiWorkerStatus.RUNNING = type("FfiWorkerStatus.RUNNING", (FfiWorkerStatus.RUNNING, FfiWorkerStatus,), {})  # type: ignore
FfiWorkerStatus.PAUSED = type("FfiWorkerStatus.PAUSED", (FfiWorkerStatus.PAUSED, FfiWorkerStatus,), {})  # type: ignore
FfiWorkerStatus.RECONNECTING = type("FfiWorkerStatus.RECONNECTING", (FfiWorkerStatus.RECONNECTING, FfiWorkerStatus,), {})  # type: ignore
FfiWorkerStatus.SHUTTING_DOWN = type("FfiWorkerStatus.SHUTTING_DOWN", (FfiWorkerStatus.SHUTTING_DOWN, FfiWorkerStatus,), {})  # type: ignore
FfiWorkerStatus.STOPPED = type("FfiWorkerStatus.STOPPED", (FfiWorkerStatus.STOPPED, FfiWorkerStatus,), {})  # type: ignore




class _UniffiConverterTypeFfiWorkerStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiWorkerStatus.INITIALIZING(
            )
        if variant == 2:
            return FfiWorkerStatus.REGISTERING(
            )
        if variant == 3:
            return FfiWorkerStatus.RUNNING(
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterInt64.read(buf),
            )
        if variant == 4:
            return FfiWorkerStatus.PAUSED(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return FfiWorkerStatus.RECONNECTING(
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 6:
            return FfiWorkerStatus.SHUTTING_DOWN(
                _UniffiConverterInt64.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 7:
            return FfiWorkerStatus.STOPPED(
                _UniffiConverterInt64.read(buf),
                _UniffiConverterTypeFfiStopReason.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_initializing():
            return
        if value.is_registering():
            return
        if value.is_running():
            _UniffiConverterOptionalString.check_lower(value.server_worker_id)
            _UniffiConverterInt64.check_lower(value.started_at_ms)
            return
        if value.is_paused():
            _UniffiConverterString.check_lower(value.reason)
            return
        if value.is_reconnecting():
            _UniffiConverterUInt32.check_lower(value.attempts)
            _UniffiConverterInt64.check_lower(value.disconnected_at_ms)
            _UniffiConverterOptionalString.check_lower(value.last_error)
            return
        if value.is_shutting_down():
            _UniffiConverterInt64.check_lower(value.requested_at_ms)
            _UniffiConverterUInt32.check_lower(value.in_flight_count)
            return
        if value.is_stopped():
            _UniffiConverterInt64.check_lower(value.stopped_at_ms)
            _UniffiConverterTypeFfiStopReason.check_lower(value.reason)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_initializing():
            buf.write_i32(1)
        if value.is_registering():
            buf.write_i32(2)
        if value.is_running():
            buf.write_i32(3)
            _UniffiConverterOptionalString.write(value.server_worker_id, buf)
            _UniffiConverterInt64.write(value.started_at_ms, buf)
        if value.is_paused():
            buf.write_i32(4)
            _UniffiConverterString.write(value.reason, buf)
        if value.is_reconnecting():
            buf.write_i32(5)
            _UniffiConverterUInt32.write(value.attempts, buf)
            _UniffiConverterInt64.write(value.disconnected_at_ms, buf)
            _UniffiConverterOptionalString.write(value.last_error, buf)
        if value.is_shutting_down():
            buf.write_i32(6)
            _UniffiConverterInt64.write(value.requested_at_ms, buf)
            _UniffiConverterUInt32.write(value.in_flight_count, buf)
        if value.is_stopped():
            buf.write_i32(7)
            _UniffiConverterInt64.write(value.stopped_at_ms, buf)
            _UniffiConverterTypeFfiStopReason.write(value.reason, buf)







class FfiWorkflowCommand:
    """
    Workflow commands that can be generated during execution.

    The language SDK processes workflow activations and generates these commands
    to be sent back to the core.
    """

    def __init__(self):
        raise RuntimeError("FfiWorkflowCommand cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class RECORD_OPERATION:
        """
        Record the result of a deterministic operation.
        """

        operation_name: "str"
        """
        Unique operation name for replay matching.
        """

        result: "bytes"
        """
        Serialized result as JSON bytes.
        """


        def __init__(self,operation_name: "str", result: "bytes"):
            self.operation_name = operation_name
            self.result = result

        def __str__(self):
            return "FfiWorkflowCommand.RECORD_OPERATION(operation_name={}, result={})".format(self.operation_name, self.result)

        def __eq__(self, other):
            if not other.is_record_operation():
                return False
            if self.operation_name != other.operation_name:
                return False
            if self.result != other.result:
                return False
            return True
    
    class SET_STATE:
        """
        Set workflow state.
        """

        key: "str"
        """
        State key.
        """

        value: "bytes"
        """
        Serialized value as JSON bytes.
        """


        def __init__(self,key: "str", value: "bytes"):
            self.key = key
            self.value = value

        def __str__(self):
            return "FfiWorkflowCommand.SET_STATE(key={}, value={})".format(self.key, self.value)

        def __eq__(self, other):
            if not other.is_set_state():
                return False
            if self.key != other.key:
                return False
            if self.value != other.value:
                return False
            return True
    
    class CLEAR_STATE:
        """
        Clear a workflow state key.
        """

        key: "str"
        """
        State key to clear.
        """


        def __init__(self,key: "str"):
            self.key = key

        def __str__(self):
            return "FfiWorkflowCommand.CLEAR_STATE(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_clear_state():
                return False
            if self.key != other.key:
                return False
            return True
    
    class SCHEDULE_TASK:
        """
        Schedule a task for execution.
        """

        task_execution_id: "str"
        """
        Unique task execution ID.
        """

        kind: "str"
        """
        Task kind.
        """

        input: "bytes"
        """
        Serialized input as JSON bytes.
        """

        priority_seconds: "typing.Optional[int]"
        """
        Optional priority in seconds.
        """

        max_retries: "typing.Optional[int]"
        """
        Optional max retries.
        """

        timeout_ms: "typing.Optional[int]"
        """
        Optional timeout in milliseconds.
        """

        queue: "typing.Optional[str]"
        """
        Optional queue name.
        """

        idempotency_key: "typing.Optional[str]"
        """
        Optional idempotency key for external correlation.
        """

        idempotency_key_ttl_seconds: "typing.Optional[int]"
        """
        Optional TTL for idempotency key in seconds.
        """


        def __init__(self,task_execution_id: "str", kind: "str", input: "bytes", priority_seconds: "typing.Optional[int]", max_retries: "typing.Optional[int]", timeout_ms: "typing.Optional[int]", queue: "typing.Optional[str]", idempotency_key: "typing.Optional[str]", idempotency_key_ttl_seconds: "typing.Optional[int]"):
            self.task_execution_id = task_execution_id
            self.kind = kind
            self.input = input
            self.priority_seconds = priority_seconds
            self.max_retries = max_retries
            self.timeout_ms = timeout_ms
            self.queue = queue
            self.idempotency_key = idempotency_key
            self.idempotency_key_ttl_seconds = idempotency_key_ttl_seconds

        def __str__(self):
            return "FfiWorkflowCommand.SCHEDULE_TASK(task_execution_id={}, kind={}, input={}, priority_seconds={}, max_retries={}, timeout_ms={}, queue={}, idempotency_key={}, idempotency_key_ttl_seconds={})".format(self.task_execution_id, self.kind, self.input, self.priority_seconds, self.max_retries, self.timeout_ms, self.queue, self.idempotency_key, self.idempotency_key_ttl_seconds)

        def __eq__(self, other):
            if not other.is_schedule_task():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            if self.kind != other.kind:
                return False
            if self.input != other.input:
                return False
            if self.priority_seconds != other.priority_seconds:
                return False
            if self.max_retries != other.max_retries:
                return False
            if self.timeout_ms != other.timeout_ms:
                return False
            if self.queue != other.queue:
                return False
            if self.idempotency_key != other.idempotency_key:
                return False
            if self.idempotency_key_ttl_seconds != other.idempotency_key_ttl_seconds:
                return False
            return True
    
    class SCHEDULE_CHILD_WORKFLOW:
        """
        Schedule a child workflow.
        """

        name: "str"
        """
        Child workflow name.
        """

        kind: "typing.Optional[str]"
        """
        Optional workflow kind.
        """

        child_execution_id: "str"
        """
        Child execution ID.
        """

        input: "bytes"
        """
        Serialized input as JSON bytes.
        """

        queue: "str"
        """
        Task queue for the child.
        """

        priority_seconds: "int"
        """
        Priority in seconds.
        """


        def __init__(self,name: "str", kind: "typing.Optional[str]", child_execution_id: "str", input: "bytes", queue: "str", priority_seconds: "int"):
            self.name = name
            self.kind = kind
            self.child_execution_id = child_execution_id
            self.input = input
            self.queue = queue
            self.priority_seconds = priority_seconds

        def __str__(self):
            return "FfiWorkflowCommand.SCHEDULE_CHILD_WORKFLOW(name={}, kind={}, child_execution_id={}, input={}, queue={}, priority_seconds={})".format(self.name, self.kind, self.child_execution_id, self.input, self.queue, self.priority_seconds)

        def __eq__(self, other):
            if not other.is_schedule_child_workflow():
                return False
            if self.name != other.name:
                return False
            if self.kind != other.kind:
                return False
            if self.child_execution_id != other.child_execution_id:
                return False
            if self.input != other.input:
                return False
            if self.queue != other.queue:
                return False
            if self.priority_seconds != other.priority_seconds:
                return False
            return True
    
    class COMPLETE_WORKFLOW:
        """
        Complete the workflow successfully.
        """

        output: "bytes"
        """
        Serialized output as JSON bytes.
        """


        def __init__(self,output: "bytes"):
            self.output = output

        def __str__(self):
            return "FfiWorkflowCommand.COMPLETE_WORKFLOW(output={})".format(self.output)

        def __eq__(self, other):
            if not other.is_complete_workflow():
                return False
            if self.output != other.output:
                return False
            return True
    
    class FAIL_WORKFLOW:
        """
        Fail the workflow with an error.
        """

        error: "str"
        """
        Error message.
        """

        stack_trace: "str"
        """
        Stack trace (optional).
        """

        failure_type: "typing.Optional[str]"
        """
        Failure type (optional).
        """


        def __init__(self,error: "str", stack_trace: "str", failure_type: "typing.Optional[str]"):
            self.error = error
            self.stack_trace = stack_trace
            self.failure_type = failure_type

        def __str__(self):
            return "FfiWorkflowCommand.FAIL_WORKFLOW(error={}, stack_trace={}, failure_type={})".format(self.error, self.stack_trace, self.failure_type)

        def __eq__(self, other):
            if not other.is_fail_workflow():
                return False
            if self.error != other.error:
                return False
            if self.stack_trace != other.stack_trace:
                return False
            if self.failure_type != other.failure_type:
                return False
            return True
    
    class SUSPEND_WORKFLOW:
        """
        Suspend the workflow.
        """

        reason: "str"
        """
        Reason for suspension.
        """


        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "FfiWorkflowCommand.SUSPEND_WORKFLOW(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_suspend_workflow():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class CANCEL_WORKFLOW:
        """
        Cancel the workflow.
        """

        reason: "str"
        """
        Reason for cancellation.
        """


        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "FfiWorkflowCommand.CANCEL_WORKFLOW(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_cancel_workflow():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class CREATE_PROMISE:
        """
        Create a durable promise.
        """

        promise_id: "str"
        """
        Promise ID.
        """

        timeout_ms: "typing.Optional[int]"
        """
        Optional timeout in milliseconds.
        """

        idempotency_key: "typing.Optional[str]"
        """
        Optional idempotency key for external webhook correlation.
        """

        idempotency_key_ttl_seconds: "typing.Optional[int]"
        """
        TTL for the idempotency key in seconds.
        """


        def __init__(self,promise_id: "str", timeout_ms: "typing.Optional[int]", idempotency_key: "typing.Optional[str]", idempotency_key_ttl_seconds: "typing.Optional[int]"):
            self.promise_id = promise_id
            self.timeout_ms = timeout_ms
            self.idempotency_key = idempotency_key
            self.idempotency_key_ttl_seconds = idempotency_key_ttl_seconds

        def __str__(self):
            return "FfiWorkflowCommand.CREATE_PROMISE(promise_id={}, timeout_ms={}, idempotency_key={}, idempotency_key_ttl_seconds={})".format(self.promise_id, self.timeout_ms, self.idempotency_key, self.idempotency_key_ttl_seconds)

        def __eq__(self, other):
            if not other.is_create_promise():
                return False
            if self.promise_id != other.promise_id:
                return False
            if self.timeout_ms != other.timeout_ms:
                return False
            if self.idempotency_key != other.idempotency_key:
                return False
            if self.idempotency_key_ttl_seconds != other.idempotency_key_ttl_seconds:
                return False
            return True
    
    class RESOLVE_PROMISE:
        """
        Resolve a durable promise.
        """

        promise_id: "str"
        """
        Promise ID.
        """

        value: "bytes"
        """
        Serialized value as JSON bytes.
        """


        def __init__(self,promise_id: "str", value: "bytes"):
            self.promise_id = promise_id
            self.value = value

        def __str__(self):
            return "FfiWorkflowCommand.RESOLVE_PROMISE(promise_id={}, value={})".format(self.promise_id, self.value)

        def __eq__(self, other):
            if not other.is_resolve_promise():
                return False
            if self.promise_id != other.promise_id:
                return False
            if self.value != other.value:
                return False
            return True
    
    class START_TIMER:
        """
        Start a timer.
        """

        timer_id: "str"
        """
        Timer ID.
        """

        duration_ms: "int"
        """
        Duration in milliseconds.
        """


        def __init__(self,timer_id: "str", duration_ms: "int"):
            self.timer_id = timer_id
            self.duration_ms = duration_ms

        def __str__(self):
            return "FfiWorkflowCommand.START_TIMER(timer_id={}, duration_ms={})".format(self.timer_id, self.duration_ms)

        def __eq__(self, other):
            if not other.is_start_timer():
                return False
            if self.timer_id != other.timer_id:
                return False
            if self.duration_ms != other.duration_ms:
                return False
            return True
    
    class CANCEL_TIMER:
        """
        Cancel a timer.
        """

        timer_id: "str"
        """
        Timer ID to cancel.
        """


        def __init__(self,timer_id: "str"):
            self.timer_id = timer_id

        def __str__(self):
            return "FfiWorkflowCommand.CANCEL_TIMER(timer_id={})".format(self.timer_id)

        def __eq__(self, other):
            if not other.is_cancel_timer():
                return False
            if self.timer_id != other.timer_id:
                return False
            return True
    
    class REQUEST_CANCEL_TASK:
        """
        Request cancellation of a task.
        """

        task_execution_id: "str"
        """
        Task execution ID to cancel.
        """


        def __init__(self,task_execution_id: "str"):
            self.task_execution_id = task_execution_id

        def __str__(self):
            return "FfiWorkflowCommand.REQUEST_CANCEL_TASK(task_execution_id={})".format(self.task_execution_id)

        def __eq__(self, other):
            if not other.is_request_cancel_task():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            return True
    
    class REQUEST_CANCEL_CHILD_WORKFLOW:
        """
        Request cancellation of a child workflow.
        """

        child_execution_id: "str"
        """
        Child execution ID to cancel.
        """


        def __init__(self,child_execution_id: "str"):
            self.child_execution_id = child_execution_id

        def __str__(self):
            return "FfiWorkflowCommand.REQUEST_CANCEL_CHILD_WORKFLOW(child_execution_id={})".format(self.child_execution_id)

        def __eq__(self, other):
            if not other.is_request_cancel_child_workflow():
                return False
            if self.child_execution_id != other.child_execution_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_record_operation(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.RECORD_OPERATION)
    def is_set_state(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.SET_STATE)
    def is_clear_state(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.CLEAR_STATE)
    def is_schedule_task(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.SCHEDULE_TASK)
    def is_schedule_child_workflow(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.SCHEDULE_CHILD_WORKFLOW)
    def is_complete_workflow(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.COMPLETE_WORKFLOW)
    def is_fail_workflow(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.FAIL_WORKFLOW)
    def is_suspend_workflow(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.SUSPEND_WORKFLOW)
    def is_cancel_workflow(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.CANCEL_WORKFLOW)
    def is_create_promise(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.CREATE_PROMISE)
    def is_resolve_promise(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.RESOLVE_PROMISE)
    def is_start_timer(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.START_TIMER)
    def is_cancel_timer(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.CANCEL_TIMER)
    def is_request_cancel_task(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.REQUEST_CANCEL_TASK)
    def is_request_cancel_child_workflow(self) -> bool:
        return isinstance(self, FfiWorkflowCommand.REQUEST_CANCEL_CHILD_WORKFLOW)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiWorkflowCommand.RECORD_OPERATION = type("FfiWorkflowCommand.RECORD_OPERATION", (FfiWorkflowCommand.RECORD_OPERATION, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.SET_STATE = type("FfiWorkflowCommand.SET_STATE", (FfiWorkflowCommand.SET_STATE, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.CLEAR_STATE = type("FfiWorkflowCommand.CLEAR_STATE", (FfiWorkflowCommand.CLEAR_STATE, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.SCHEDULE_TASK = type("FfiWorkflowCommand.SCHEDULE_TASK", (FfiWorkflowCommand.SCHEDULE_TASK, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.SCHEDULE_CHILD_WORKFLOW = type("FfiWorkflowCommand.SCHEDULE_CHILD_WORKFLOW", (FfiWorkflowCommand.SCHEDULE_CHILD_WORKFLOW, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.COMPLETE_WORKFLOW = type("FfiWorkflowCommand.COMPLETE_WORKFLOW", (FfiWorkflowCommand.COMPLETE_WORKFLOW, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.FAIL_WORKFLOW = type("FfiWorkflowCommand.FAIL_WORKFLOW", (FfiWorkflowCommand.FAIL_WORKFLOW, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.SUSPEND_WORKFLOW = type("FfiWorkflowCommand.SUSPEND_WORKFLOW", (FfiWorkflowCommand.SUSPEND_WORKFLOW, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.CANCEL_WORKFLOW = type("FfiWorkflowCommand.CANCEL_WORKFLOW", (FfiWorkflowCommand.CANCEL_WORKFLOW, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.CREATE_PROMISE = type("FfiWorkflowCommand.CREATE_PROMISE", (FfiWorkflowCommand.CREATE_PROMISE, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.RESOLVE_PROMISE = type("FfiWorkflowCommand.RESOLVE_PROMISE", (FfiWorkflowCommand.RESOLVE_PROMISE, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.START_TIMER = type("FfiWorkflowCommand.START_TIMER", (FfiWorkflowCommand.START_TIMER, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.CANCEL_TIMER = type("FfiWorkflowCommand.CANCEL_TIMER", (FfiWorkflowCommand.CANCEL_TIMER, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.REQUEST_CANCEL_TASK = type("FfiWorkflowCommand.REQUEST_CANCEL_TASK", (FfiWorkflowCommand.REQUEST_CANCEL_TASK, FfiWorkflowCommand,), {})  # type: ignore
FfiWorkflowCommand.REQUEST_CANCEL_CHILD_WORKFLOW = type("FfiWorkflowCommand.REQUEST_CANCEL_CHILD_WORKFLOW", (FfiWorkflowCommand.REQUEST_CANCEL_CHILD_WORKFLOW, FfiWorkflowCommand,), {})  # type: ignore




class _UniffiConverterTypeFfiWorkflowCommand(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiWorkflowCommand.RECORD_OPERATION(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return FfiWorkflowCommand.SET_STATE(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 3:
            return FfiWorkflowCommand.CLEAR_STATE(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return FfiWorkflowCommand.SCHEDULE_TASK(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
                _UniffiConverterOptionalInt32.read(buf),
                _UniffiConverterOptionalUInt32.read(buf),
                _UniffiConverterOptionalInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalInt64.read(buf),
            )
        if variant == 5:
            return FfiWorkflowCommand.SCHEDULE_CHILD_WORKFLOW(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterInt32.read(buf),
            )
        if variant == 6:
            return FfiWorkflowCommand.COMPLETE_WORKFLOW(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 7:
            return FfiWorkflowCommand.FAIL_WORKFLOW(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 8:
            return FfiWorkflowCommand.SUSPEND_WORKFLOW(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return FfiWorkflowCommand.CANCEL_WORKFLOW(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return FfiWorkflowCommand.CREATE_PROMISE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalInt64.read(buf),
            )
        if variant == 11:
            return FfiWorkflowCommand.RESOLVE_PROMISE(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 12:
            return FfiWorkflowCommand.START_TIMER(
                _UniffiConverterString.read(buf),
                _UniffiConverterInt64.read(buf),
            )
        if variant == 13:
            return FfiWorkflowCommand.CANCEL_TIMER(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return FfiWorkflowCommand.REQUEST_CANCEL_TASK(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return FfiWorkflowCommand.REQUEST_CANCEL_CHILD_WORKFLOW(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_record_operation():
            _UniffiConverterString.check_lower(value.operation_name)
            _UniffiConverterBytes.check_lower(value.result)
            return
        if value.is_set_state():
            _UniffiConverterString.check_lower(value.key)
            _UniffiConverterBytes.check_lower(value.value)
            return
        if value.is_clear_state():
            _UniffiConverterString.check_lower(value.key)
            return
        if value.is_schedule_task():
            _UniffiConverterString.check_lower(value.task_execution_id)
            _UniffiConverterString.check_lower(value.kind)
            _UniffiConverterBytes.check_lower(value.input)
            _UniffiConverterOptionalInt32.check_lower(value.priority_seconds)
            _UniffiConverterOptionalUInt32.check_lower(value.max_retries)
            _UniffiConverterOptionalInt64.check_lower(value.timeout_ms)
            _UniffiConverterOptionalString.check_lower(value.queue)
            _UniffiConverterOptionalString.check_lower(value.idempotency_key)
            _UniffiConverterOptionalInt64.check_lower(value.idempotency_key_ttl_seconds)
            return
        if value.is_schedule_child_workflow():
            _UniffiConverterString.check_lower(value.name)
            _UniffiConverterOptionalString.check_lower(value.kind)
            _UniffiConverterString.check_lower(value.child_execution_id)
            _UniffiConverterBytes.check_lower(value.input)
            _UniffiConverterString.check_lower(value.queue)
            _UniffiConverterInt32.check_lower(value.priority_seconds)
            return
        if value.is_complete_workflow():
            _UniffiConverterBytes.check_lower(value.output)
            return
        if value.is_fail_workflow():
            _UniffiConverterString.check_lower(value.error)
            _UniffiConverterString.check_lower(value.stack_trace)
            _UniffiConverterOptionalString.check_lower(value.failure_type)
            return
        if value.is_suspend_workflow():
            _UniffiConverterString.check_lower(value.reason)
            return
        if value.is_cancel_workflow():
            _UniffiConverterString.check_lower(value.reason)
            return
        if value.is_create_promise():
            _UniffiConverterString.check_lower(value.promise_id)
            _UniffiConverterOptionalInt64.check_lower(value.timeout_ms)
            _UniffiConverterOptionalString.check_lower(value.idempotency_key)
            _UniffiConverterOptionalInt64.check_lower(value.idempotency_key_ttl_seconds)
            return
        if value.is_resolve_promise():
            _UniffiConverterString.check_lower(value.promise_id)
            _UniffiConverterBytes.check_lower(value.value)
            return
        if value.is_start_timer():
            _UniffiConverterString.check_lower(value.timer_id)
            _UniffiConverterInt64.check_lower(value.duration_ms)
            return
        if value.is_cancel_timer():
            _UniffiConverterString.check_lower(value.timer_id)
            return
        if value.is_request_cancel_task():
            _UniffiConverterString.check_lower(value.task_execution_id)
            return
        if value.is_request_cancel_child_workflow():
            _UniffiConverterString.check_lower(value.child_execution_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_record_operation():
            buf.write_i32(1)
            _UniffiConverterString.write(value.operation_name, buf)
            _UniffiConverterBytes.write(value.result, buf)
        if value.is_set_state():
            buf.write_i32(2)
            _UniffiConverterString.write(value.key, buf)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_clear_state():
            buf.write_i32(3)
            _UniffiConverterString.write(value.key, buf)
        if value.is_schedule_task():
            buf.write_i32(4)
            _UniffiConverterString.write(value.task_execution_id, buf)
            _UniffiConverterString.write(value.kind, buf)
            _UniffiConverterBytes.write(value.input, buf)
            _UniffiConverterOptionalInt32.write(value.priority_seconds, buf)
            _UniffiConverterOptionalUInt32.write(value.max_retries, buf)
            _UniffiConverterOptionalInt64.write(value.timeout_ms, buf)
            _UniffiConverterOptionalString.write(value.queue, buf)
            _UniffiConverterOptionalString.write(value.idempotency_key, buf)
            _UniffiConverterOptionalInt64.write(value.idempotency_key_ttl_seconds, buf)
        if value.is_schedule_child_workflow():
            buf.write_i32(5)
            _UniffiConverterString.write(value.name, buf)
            _UniffiConverterOptionalString.write(value.kind, buf)
            _UniffiConverterString.write(value.child_execution_id, buf)
            _UniffiConverterBytes.write(value.input, buf)
            _UniffiConverterString.write(value.queue, buf)
            _UniffiConverterInt32.write(value.priority_seconds, buf)
        if value.is_complete_workflow():
            buf.write_i32(6)
            _UniffiConverterBytes.write(value.output, buf)
        if value.is_fail_workflow():
            buf.write_i32(7)
            _UniffiConverterString.write(value.error, buf)
            _UniffiConverterString.write(value.stack_trace, buf)
            _UniffiConverterOptionalString.write(value.failure_type, buf)
        if value.is_suspend_workflow():
            buf.write_i32(8)
            _UniffiConverterString.write(value.reason, buf)
        if value.is_cancel_workflow():
            buf.write_i32(9)
            _UniffiConverterString.write(value.reason, buf)
        if value.is_create_promise():
            buf.write_i32(10)
            _UniffiConverterString.write(value.promise_id, buf)
            _UniffiConverterOptionalInt64.write(value.timeout_ms, buf)
            _UniffiConverterOptionalString.write(value.idempotency_key, buf)
            _UniffiConverterOptionalInt64.write(value.idempotency_key_ttl_seconds, buf)
        if value.is_resolve_promise():
            buf.write_i32(11)
            _UniffiConverterString.write(value.promise_id, buf)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_start_timer():
            buf.write_i32(12)
            _UniffiConverterString.write(value.timer_id, buf)
            _UniffiConverterInt64.write(value.duration_ms, buf)
        if value.is_cancel_timer():
            buf.write_i32(13)
            _UniffiConverterString.write(value.timer_id, buf)
        if value.is_request_cancel_task():
            buf.write_i32(14)
            _UniffiConverterString.write(value.task_execution_id, buf)
        if value.is_request_cancel_child_workflow():
            buf.write_i32(15)
            _UniffiConverterString.write(value.child_execution_id, buf)







class TaskCompletion:
    """
    Completion sent back after processing a task activation.
    """

    def __init__(self):
        raise RuntimeError("TaskCompletion cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COMPLETED:
        """
        Task completed successfully.
        """

        task_execution_id: "str"
        """
        The task execution ID.
        """

        output: "bytes"
        """
        Serialized output as JSON bytes.
        """


        def __init__(self,task_execution_id: "str", output: "bytes"):
            self.task_execution_id = task_execution_id
            self.output = output

        def __str__(self):
            return "TaskCompletion.COMPLETED(task_execution_id={}, output={})".format(self.task_execution_id, self.output)

        def __eq__(self, other):
            if not other.is_completed():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            if self.output != other.output:
                return False
            return True
    
    class FAILED:
        """
        Task failed.
        """

        task_execution_id: "str"
        """
        The task execution ID.
        """

        error: "str"
        """
        Error message.
        """

        retryable: "bool"
        """
        Whether this is retryable.
        """


        def __init__(self,task_execution_id: "str", error: "str", retryable: "bool"):
            self.task_execution_id = task_execution_id
            self.error = error
            self.retryable = retryable

        def __str__(self):
            return "TaskCompletion.FAILED(task_execution_id={}, error={}, retryable={})".format(self.task_execution_id, self.error, self.retryable)

        def __eq__(self, other):
            if not other.is_failed():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            if self.error != other.error:
                return False
            if self.retryable != other.retryable:
                return False
            return True
    
    class CANCELLED:
        """
        Task was cancelled.
        """

        task_execution_id: "str"
        """
        The task execution ID.
        """


        def __init__(self,task_execution_id: "str"):
            self.task_execution_id = task_execution_id

        def __str__(self):
            return "TaskCompletion.CANCELLED(task_execution_id={})".format(self.task_execution_id)

        def __eq__(self, other):
            if not other.is_cancelled():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_completed(self) -> bool:
        return isinstance(self, TaskCompletion.COMPLETED)
    def is_failed(self) -> bool:
        return isinstance(self, TaskCompletion.FAILED)
    def is_cancelled(self) -> bool:
        return isinstance(self, TaskCompletion.CANCELLED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TaskCompletion.COMPLETED = type("TaskCompletion.COMPLETED", (TaskCompletion.COMPLETED, TaskCompletion,), {})  # type: ignore
TaskCompletion.FAILED = type("TaskCompletion.FAILED", (TaskCompletion.FAILED, TaskCompletion,), {})  # type: ignore
TaskCompletion.CANCELLED = type("TaskCompletion.CANCELLED", (TaskCompletion.CANCELLED, TaskCompletion,), {})  # type: ignore




class _UniffiConverterTypeTaskCompletion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TaskCompletion.COMPLETED(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return TaskCompletion.FAILED(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return TaskCompletion.CANCELLED(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_completed():
            _UniffiConverterString.check_lower(value.task_execution_id)
            _UniffiConverterBytes.check_lower(value.output)
            return
        if value.is_failed():
            _UniffiConverterString.check_lower(value.task_execution_id)
            _UniffiConverterString.check_lower(value.error)
            _UniffiConverterBool.check_lower(value.retryable)
            return
        if value.is_cancelled():
            _UniffiConverterString.check_lower(value.task_execution_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_completed():
            buf.write_i32(1)
            _UniffiConverterString.write(value.task_execution_id, buf)
            _UniffiConverterBytes.write(value.output, buf)
        if value.is_failed():
            buf.write_i32(2)
            _UniffiConverterString.write(value.task_execution_id, buf)
            _UniffiConverterString.write(value.error, buf)
            _UniffiConverterBool.write(value.retryable, buf)
        if value.is_cancelled():
            buf.write_i32(3)
            _UniffiConverterString.write(value.task_execution_id, buf)







class WorkflowActivationJob:
    """
    Jobs that can be included in a workflow activation.
    """

    def __init__(self):
        raise RuntimeError("WorkflowActivationJob cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INITIALIZE:
        """
        Initialize/start the workflow.
        """

        input: "bytes"
        """
        Serialized workflow input as JSON bytes.
        """


        def __init__(self,input: "bytes"):
            self.input = input

        def __str__(self):
            return "WorkflowActivationJob.INITIALIZE(input={})".format(self.input)

        def __eq__(self, other):
            if not other.is_initialize():
                return False
            if self.input != other.input:
                return False
            return True
    
    class FIRE_TIMER:
        """
        A timer has fired.
        """

        timer_id: "str"
        """
        The timer ID that fired.
        """


        def __init__(self,timer_id: "str"):
            self.timer_id = timer_id

        def __str__(self):
            return "WorkflowActivationJob.FIRE_TIMER(timer_id={})".format(self.timer_id)

        def __eq__(self, other):
            if not other.is_fire_timer():
                return False
            if self.timer_id != other.timer_id:
                return False
            return True
    
    class RESOLVE_TASK:
        """
        A scheduled task has completed.
        """

        task_execution_id: "str"
        """
        The task execution ID.
        """

        result: "bytes"
        """
        Serialized task result as JSON bytes.
        """


        def __init__(self,task_execution_id: "str", result: "bytes"):
            self.task_execution_id = task_execution_id
            self.result = result

        def __str__(self):
            return "WorkflowActivationJob.RESOLVE_TASK(task_execution_id={}, result={})".format(self.task_execution_id, self.result)

        def __eq__(self, other):
            if not other.is_resolve_task():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            if self.result != other.result:
                return False
            return True
    
    class FAIL_TASK:
        """
        A scheduled task has failed.
        """

        task_execution_id: "str"
        """
        The task execution ID.
        """

        error: "str"
        """
        Error message.
        """

        retryable: "bool"
        """
        Whether this is retryable.
        """


        def __init__(self,task_execution_id: "str", error: "str", retryable: "bool"):
            self.task_execution_id = task_execution_id
            self.error = error
            self.retryable = retryable

        def __str__(self):
            return "WorkflowActivationJob.FAIL_TASK(task_execution_id={}, error={}, retryable={})".format(self.task_execution_id, self.error, self.retryable)

        def __eq__(self, other):
            if not other.is_fail_task():
                return False
            if self.task_execution_id != other.task_execution_id:
                return False
            if self.error != other.error:
                return False
            if self.retryable != other.retryable:
                return False
            return True
    
    class RESOLVE_PROMISE:
        """
        A durable promise has been resolved.
        """

        promise_name: "str"
        """
        The promise name/ID.
        """

        value: "bytes"
        """
        Serialized promise value as JSON bytes.
        """


        def __init__(self,promise_name: "str", value: "bytes"):
            self.promise_name = promise_name
            self.value = value

        def __str__(self):
            return "WorkflowActivationJob.RESOLVE_PROMISE(promise_name={}, value={})".format(self.promise_name, self.value)

        def __eq__(self, other):
            if not other.is_resolve_promise():
                return False
            if self.promise_name != other.promise_name:
                return False
            if self.value != other.value:
                return False
            return True
    
    class REJECT_PROMISE:
        """
        A durable promise has been rejected.
        """

        promise_name: "str"
        """
        The promise name/ID.
        """

        error: "str"
        """
        Error message.
        """


        def __init__(self,promise_name: "str", error: "str"):
            self.promise_name = promise_name
            self.error = error

        def __str__(self):
            return "WorkflowActivationJob.REJECT_PROMISE(promise_name={}, error={})".format(self.promise_name, self.error)

        def __eq__(self, other):
            if not other.is_reject_promise():
                return False
            if self.promise_name != other.promise_name:
                return False
            if self.error != other.error:
                return False
            return True
    
    class TIMEOUT_PROMISE:
        """
        A durable promise has timed out.
        """

        promise_name: "str"
        """
        The promise name/ID.
        """


        def __init__(self,promise_name: "str"):
            self.promise_name = promise_name

        def __str__(self):
            return "WorkflowActivationJob.TIMEOUT_PROMISE(promise_name={})".format(self.promise_name)

        def __eq__(self, other):
            if not other.is_timeout_promise():
                return False
            if self.promise_name != other.promise_name:
                return False
            return True
    
    class RESOLVE_CHILD_WORKFLOW:
        """
        A child workflow has completed.
        """

        child_execution_id: "str"
        """
        The child workflow execution ID.
        """

        result: "bytes"
        """
        Serialized result as JSON bytes.
        """


        def __init__(self,child_execution_id: "str", result: "bytes"):
            self.child_execution_id = child_execution_id
            self.result = result

        def __str__(self):
            return "WorkflowActivationJob.RESOLVE_CHILD_WORKFLOW(child_execution_id={}, result={})".format(self.child_execution_id, self.result)

        def __eq__(self, other):
            if not other.is_resolve_child_workflow():
                return False
            if self.child_execution_id != other.child_execution_id:
                return False
            if self.result != other.result:
                return False
            return True
    
    class FAIL_CHILD_WORKFLOW:
        """
        A child workflow has failed.
        """

        child_execution_id: "str"
        """
        The child workflow execution ID.
        """

        error: "str"
        """
        Error message.
        """


        def __init__(self,child_execution_id: "str", error: "str"):
            self.child_execution_id = child_execution_id
            self.error = error

        def __str__(self):
            return "WorkflowActivationJob.FAIL_CHILD_WORKFLOW(child_execution_id={}, error={})".format(self.child_execution_id, self.error)

        def __eq__(self, other):
            if not other.is_fail_child_workflow():
                return False
            if self.child_execution_id != other.child_execution_id:
                return False
            if self.error != other.error:
                return False
            return True
    
    class CANCEL_WORKFLOW:
        """
        A cancellation has been requested.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "WorkflowActivationJob.CANCEL_WORKFLOW()".format()

        def __eq__(self, other):
            if not other.is_cancel_workflow():
                return False
            return True
    
    class SIGNAL:
        """
        A signal was received (external event).
        """

        signal_name: "str"
        """
        Signal name.
        """

        payload: "bytes"
        """
        Serialized signal payload as JSON bytes.
        """


        def __init__(self,signal_name: "str", payload: "bytes"):
            self.signal_name = signal_name
            self.payload = payload

        def __str__(self):
            return "WorkflowActivationJob.SIGNAL(signal_name={}, payload={})".format(self.signal_name, self.payload)

        def __eq__(self, other):
            if not other.is_signal():
                return False
            if self.signal_name != other.signal_name:
                return False
            if self.payload != other.payload:
                return False
            return True
    
    class QUERY:
        """
        Query the workflow state (read-only).
        """

        query_name: "str"
        """
        Query name.
        """

        args: "bytes"
        """
        Serialized query args as JSON bytes.
        """


        def __init__(self,query_name: "str", args: "bytes"):
            self.query_name = query_name
            self.args = args

        def __str__(self):
            return "WorkflowActivationJob.QUERY(query_name={}, args={})".format(self.query_name, self.args)

        def __eq__(self, other):
            if not other.is_query():
                return False
            if self.query_name != other.query_name:
                return False
            if self.args != other.args:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_initialize(self) -> bool:
        return isinstance(self, WorkflowActivationJob.INITIALIZE)
    def is_fire_timer(self) -> bool:
        return isinstance(self, WorkflowActivationJob.FIRE_TIMER)
    def is_resolve_task(self) -> bool:
        return isinstance(self, WorkflowActivationJob.RESOLVE_TASK)
    def is_fail_task(self) -> bool:
        return isinstance(self, WorkflowActivationJob.FAIL_TASK)
    def is_resolve_promise(self) -> bool:
        return isinstance(self, WorkflowActivationJob.RESOLVE_PROMISE)
    def is_reject_promise(self) -> bool:
        return isinstance(self, WorkflowActivationJob.REJECT_PROMISE)
    def is_timeout_promise(self) -> bool:
        return isinstance(self, WorkflowActivationJob.TIMEOUT_PROMISE)
    def is_resolve_child_workflow(self) -> bool:
        return isinstance(self, WorkflowActivationJob.RESOLVE_CHILD_WORKFLOW)
    def is_fail_child_workflow(self) -> bool:
        return isinstance(self, WorkflowActivationJob.FAIL_CHILD_WORKFLOW)
    def is_cancel_workflow(self) -> bool:
        return isinstance(self, WorkflowActivationJob.CANCEL_WORKFLOW)
    def is_signal(self) -> bool:
        return isinstance(self, WorkflowActivationJob.SIGNAL)
    def is_query(self) -> bool:
        return isinstance(self, WorkflowActivationJob.QUERY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WorkflowActivationJob.INITIALIZE = type("WorkflowActivationJob.INITIALIZE", (WorkflowActivationJob.INITIALIZE, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.FIRE_TIMER = type("WorkflowActivationJob.FIRE_TIMER", (WorkflowActivationJob.FIRE_TIMER, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.RESOLVE_TASK = type("WorkflowActivationJob.RESOLVE_TASK", (WorkflowActivationJob.RESOLVE_TASK, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.FAIL_TASK = type("WorkflowActivationJob.FAIL_TASK", (WorkflowActivationJob.FAIL_TASK, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.RESOLVE_PROMISE = type("WorkflowActivationJob.RESOLVE_PROMISE", (WorkflowActivationJob.RESOLVE_PROMISE, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.REJECT_PROMISE = type("WorkflowActivationJob.REJECT_PROMISE", (WorkflowActivationJob.REJECT_PROMISE, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.TIMEOUT_PROMISE = type("WorkflowActivationJob.TIMEOUT_PROMISE", (WorkflowActivationJob.TIMEOUT_PROMISE, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.RESOLVE_CHILD_WORKFLOW = type("WorkflowActivationJob.RESOLVE_CHILD_WORKFLOW", (WorkflowActivationJob.RESOLVE_CHILD_WORKFLOW, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.FAIL_CHILD_WORKFLOW = type("WorkflowActivationJob.FAIL_CHILD_WORKFLOW", (WorkflowActivationJob.FAIL_CHILD_WORKFLOW, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.CANCEL_WORKFLOW = type("WorkflowActivationJob.CANCEL_WORKFLOW", (WorkflowActivationJob.CANCEL_WORKFLOW, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.SIGNAL = type("WorkflowActivationJob.SIGNAL", (WorkflowActivationJob.SIGNAL, WorkflowActivationJob,), {})  # type: ignore
WorkflowActivationJob.QUERY = type("WorkflowActivationJob.QUERY", (WorkflowActivationJob.QUERY, WorkflowActivationJob,), {})  # type: ignore




class _UniffiConverterTypeWorkflowActivationJob(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WorkflowActivationJob.INITIALIZE(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return WorkflowActivationJob.FIRE_TIMER(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return WorkflowActivationJob.RESOLVE_TASK(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 4:
            return WorkflowActivationJob.FAIL_TASK(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 5:
            return WorkflowActivationJob.RESOLVE_PROMISE(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 6:
            return WorkflowActivationJob.REJECT_PROMISE(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return WorkflowActivationJob.TIMEOUT_PROMISE(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return WorkflowActivationJob.RESOLVE_CHILD_WORKFLOW(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 9:
            return WorkflowActivationJob.FAIL_CHILD_WORKFLOW(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return WorkflowActivationJob.CANCEL_WORKFLOW(
            )
        if variant == 11:
            return WorkflowActivationJob.SIGNAL(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        if variant == 12:
            return WorkflowActivationJob.QUERY(
                _UniffiConverterString.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_initialize():
            _UniffiConverterBytes.check_lower(value.input)
            return
        if value.is_fire_timer():
            _UniffiConverterString.check_lower(value.timer_id)
            return
        if value.is_resolve_task():
            _UniffiConverterString.check_lower(value.task_execution_id)
            _UniffiConverterBytes.check_lower(value.result)
            return
        if value.is_fail_task():
            _UniffiConverterString.check_lower(value.task_execution_id)
            _UniffiConverterString.check_lower(value.error)
            _UniffiConverterBool.check_lower(value.retryable)
            return
        if value.is_resolve_promise():
            _UniffiConverterString.check_lower(value.promise_name)
            _UniffiConverterBytes.check_lower(value.value)
            return
        if value.is_reject_promise():
            _UniffiConverterString.check_lower(value.promise_name)
            _UniffiConverterString.check_lower(value.error)
            return
        if value.is_timeout_promise():
            _UniffiConverterString.check_lower(value.promise_name)
            return
        if value.is_resolve_child_workflow():
            _UniffiConverterString.check_lower(value.child_execution_id)
            _UniffiConverterBytes.check_lower(value.result)
            return
        if value.is_fail_child_workflow():
            _UniffiConverterString.check_lower(value.child_execution_id)
            _UniffiConverterString.check_lower(value.error)
            return
        if value.is_cancel_workflow():
            return
        if value.is_signal():
            _UniffiConverterString.check_lower(value.signal_name)
            _UniffiConverterBytes.check_lower(value.payload)
            return
        if value.is_query():
            _UniffiConverterString.check_lower(value.query_name)
            _UniffiConverterBytes.check_lower(value.args)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_initialize():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.input, buf)
        if value.is_fire_timer():
            buf.write_i32(2)
            _UniffiConverterString.write(value.timer_id, buf)
        if value.is_resolve_task():
            buf.write_i32(3)
            _UniffiConverterString.write(value.task_execution_id, buf)
            _UniffiConverterBytes.write(value.result, buf)
        if value.is_fail_task():
            buf.write_i32(4)
            _UniffiConverterString.write(value.task_execution_id, buf)
            _UniffiConverterString.write(value.error, buf)
            _UniffiConverterBool.write(value.retryable, buf)
        if value.is_resolve_promise():
            buf.write_i32(5)
            _UniffiConverterString.write(value.promise_name, buf)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_reject_promise():
            buf.write_i32(6)
            _UniffiConverterString.write(value.promise_name, buf)
            _UniffiConverterString.write(value.error, buf)
        if value.is_timeout_promise():
            buf.write_i32(7)
            _UniffiConverterString.write(value.promise_name, buf)
        if value.is_resolve_child_workflow():
            buf.write_i32(8)
            _UniffiConverterString.write(value.child_execution_id, buf)
            _UniffiConverterBytes.write(value.result, buf)
        if value.is_fail_child_workflow():
            buf.write_i32(9)
            _UniffiConverterString.write(value.child_execution_id, buf)
            _UniffiConverterString.write(value.error, buf)
        if value.is_cancel_workflow():
            buf.write_i32(10)
        if value.is_signal():
            buf.write_i32(11)
            _UniffiConverterString.write(value.signal_name, buf)
            _UniffiConverterBytes.write(value.payload, buf)
        if value.is_query():
            buf.write_i32(12)
            _UniffiConverterString.write(value.query_name, buf)
            _UniffiConverterBytes.write(value.args, buf)







class WorkflowCompletionStatus:
    """
    Status to report when completing a workflow activation.

    Used with `CoreWorker::complete_workflow_activation()`.
    Commands are automatically extracted from the context.
    """

    def __init__(self):
        raise RuntimeError("WorkflowCompletionStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COMPLETED:
        """
        Workflow completed successfully with output.
        """

        output: "bytes"
        """
        Serialized output as JSON bytes.
        """


        def __init__(self,output: "bytes"):
            self.output = output

        def __str__(self):
            return "WorkflowCompletionStatus.COMPLETED(output={})".format(self.output)

        def __eq__(self, other):
            if not other.is_completed():
                return False
            if self.output != other.output:
                return False
            return True
    
    class SUSPENDED:
        """
        Workflow suspended waiting for external events.

        The workflow will be resumed when a task completes, timer fires,
        promise resolves, or child workflow finishes.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "WorkflowCompletionStatus.SUSPENDED()".format()

        def __eq__(self, other):
            if not other.is_suspended():
                return False
            return True
    
    class CANCELLED:
        """
        Workflow was cancelled.
        """

        reason: "str"
        """
        Reason for cancellation.
        """


        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "WorkflowCompletionStatus.CANCELLED(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_cancelled():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class FAILED:
        """
        Workflow failed with an error.
        """

        error: "str"
        """
        Error message.
        """


        def __init__(self,error: "str"):
            self.error = error

        def __str__(self):
            return "WorkflowCompletionStatus.FAILED(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_failed():
                return False
            if self.error != other.error:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_completed(self) -> bool:
        return isinstance(self, WorkflowCompletionStatus.COMPLETED)
    def is_suspended(self) -> bool:
        return isinstance(self, WorkflowCompletionStatus.SUSPENDED)
    def is_cancelled(self) -> bool:
        return isinstance(self, WorkflowCompletionStatus.CANCELLED)
    def is_failed(self) -> bool:
        return isinstance(self, WorkflowCompletionStatus.FAILED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WorkflowCompletionStatus.COMPLETED = type("WorkflowCompletionStatus.COMPLETED", (WorkflowCompletionStatus.COMPLETED, WorkflowCompletionStatus,), {})  # type: ignore
WorkflowCompletionStatus.SUSPENDED = type("WorkflowCompletionStatus.SUSPENDED", (WorkflowCompletionStatus.SUSPENDED, WorkflowCompletionStatus,), {})  # type: ignore
WorkflowCompletionStatus.CANCELLED = type("WorkflowCompletionStatus.CANCELLED", (WorkflowCompletionStatus.CANCELLED, WorkflowCompletionStatus,), {})  # type: ignore
WorkflowCompletionStatus.FAILED = type("WorkflowCompletionStatus.FAILED", (WorkflowCompletionStatus.FAILED, WorkflowCompletionStatus,), {})  # type: ignore




class _UniffiConverterTypeWorkflowCompletionStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WorkflowCompletionStatus.COMPLETED(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return WorkflowCompletionStatus.SUSPENDED(
            )
        if variant == 3:
            return WorkflowCompletionStatus.CANCELLED(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return WorkflowCompletionStatus.FAILED(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_completed():
            _UniffiConverterBytes.check_lower(value.output)
            return
        if value.is_suspended():
            return
        if value.is_cancelled():
            _UniffiConverterString.check_lower(value.reason)
            return
        if value.is_failed():
            _UniffiConverterString.check_lower(value.error)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_completed():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.output, buf)
        if value.is_suspended():
            buf.write_i32(2)
        if value.is_cancelled():
            buf.write_i32(3)
            _UniffiConverterString.write(value.reason, buf)
        if value.is_failed():
            buf.write_i32(4)
            _UniffiConverterString.write(value.error, buf)





class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiRegistrationInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiRegistrationInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiRegistrationInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiRegistrationInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeOAuth2Credentials(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeOAuth2Credentials.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeOAuth2Credentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeOAuth2Credentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTaskActivation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTaskActivation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTaskActivation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTaskActivation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeWorkflowActivation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeWorkflowActivation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeWorkflowActivation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeWorkflowActivation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiSignalEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiSignalEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiSignalEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiSignalEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLifecycleEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLifecycleEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLifecycleEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLifecycleEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTaskMetadataFfi(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTaskMetadataFfi.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTaskMetadataFfi.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTaskMetadataFfi.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeWorkflowEventRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeWorkflowEventRecord.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeWorkflowEventRecord.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeWorkflowEventRecord.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeWorkflowMetadataFfi(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeWorkflowMetadataFfi.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeWorkflowMetadataFfi.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeWorkflowMetadataFfi.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiWorkflowCommand(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiWorkflowCommand.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiWorkflowCommand.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiWorkflowCommand.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeWorkflowActivationJob(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeWorkflowActivationJob.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeWorkflowActivationJob.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeWorkflowActivationJob.read(buf) for i in range(count)
        ]

# Async support

__all__ = [
    "InternalError",
    "FfiChildWorkflowResult",
    "FfiError",
    "FfiEventType",
    "FfiOperationResult",
    "FfiPromiseResult",
    "FfiSignalResult",
    "FfiStopReason",
    "FfiStreamEvent",
    "FfiTaskExecutionResult",
    "FfiTaskResult",
    "FfiTimerResult",
    "FfiWorkerStatus",
    "FfiWorkflowCommand",
    "TaskCompletion",
    "WorkflowActivationJob",
    "WorkflowCompletionStatus",
    "ClientConfig",
    "FfiConnectionInfo",
    "FfiRegistrationInfo",
    "FfiReplayEvent",
    "FfiSignalEvent",
    "LifecycleEvent",
    "OAuth2Credentials",
    "SignalWithStartResponse",
    "SignalWorkflowResponse",
    "StartWorkflowResponse",
    "StateEntry",
    "TaskActivation",
    "TaskMetadataFfi",
    "WorkerConfig",
    "WorkerMetrics",
    "WorkflowActivation",
    "WorkflowEventRecord",
    "WorkflowMetadataFfi",
    "CoreClient",
    "CoreWorker",
    "FfiTaskContext",
    "FfiWorkflowContext",
]

